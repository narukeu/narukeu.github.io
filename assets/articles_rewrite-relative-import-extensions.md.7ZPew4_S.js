import{_ as i,c as a,o as e,ag as t}from"./chunks/framework.lo-SgHyK.js";const c=JSON.parse('{"title":"聊下 rewriteRelativeImportExtensions 这个 TS 配置项","description":"","frontmatter":{},"headers":[],"relativePath":"articles/rewrite-relative-import-extensions.md","filePath":"articles/rewrite-relative-import-extensions.md","lastUpdated":1766120941000}'),n={name:"articles/rewrite-relative-import-extensions.md"};function p(l,s,h,o,r,k){return e(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="聊下-rewriterelativeimportextensions-这个-ts-配置项" tabindex="-1">聊下 <code>rewriteRelativeImportExtensions</code> 这个 TS 配置项 <a class="header-anchor" href="#聊下-rewriterelativeimportextensions-这个-ts-配置项" aria-label="Permalink to “聊下 rewriteRelativeImportExtensions 这个 TS 配置项”">​</a></h1><h2 id="_0-前言" tabindex="-1">0. 前言 <a class="header-anchor" href="#_0-前言" aria-label="Permalink to “0. 前言”">​</a></h2><p>这个配置项是 TypeScript 5.7+ 版本中存在的，距离 5.7 发布也有一年多了，不过感觉国内的技术文章里面提及这一块的不算太多。结合我之前写前端的时候对 ESM 模块系统有一些误会，所以我觉得可以从 ESM 模块系统开始，一直科普到 TypeScript 5.7 的 <code>rewriteRelativeImportExtensions</code> 这个配置项。</p><h2 id="_1-为什么我们在开发前端项目的时候很多时候不需要写扩展名" tabindex="-1">1. 为什么我们在开发前端项目的时候很多时候不需要写扩展名 <a class="header-anchor" href="#_1-为什么我们在开发前端项目的时候很多时候不需要写扩展名" aria-label="Permalink to “1. 为什么我们在开发前端项目的时候很多时候不需要写扩展名”">​</a></h2><p>其实用 Webpack + JavaScript 的年代很多时候我们就会在 import 的时候省略掉扩展名。</p><p><code>Ruoyi-Vue</code> 仓库的主分支还是 Webpack + Vue CLI + JavaScript + Vue 2 的老项目，我们以它为例，我们会看到有这样的写法：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { parseTime } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./ruoyi&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> store </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@/store&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>实际上，<code>./ruoyi</code> 解析的是 <code>./ruoyi.js</code>，<code>@/store</code> 解析的是 <code>src/store/index.js</code>（<code>@</code> 是路径别名，我们这里不介绍）。</p><p>对于那些用 Vite、TypeScript、Nextjs 的新项目也是类似的，很多时候我们也不会写扩展名。</p><p>这样写当然有不少好处，比如代码更简洁、重构路径更方便等等。</p><p>不过这样写多了，可能会造成一个误会，会以为，我们导入 JS 模块的时候，不需要写后缀，或者，导入一个有 index 模块的目录的时候，也不需要写后缀。我以前也是这么想的。</p><p>其实没有。这些之所以能不写扩展名，是因为打包工具帮我们处理好了。如果从 ESM 规范的角度来看，导入模块的时候，还是必须要写扩展名的。</p><h2 id="_2-pure-esm-和去打包工具化" tabindex="-1">2. Pure ESM 和去打包工具化 <a class="header-anchor" href="#_2-pure-esm-和去打包工具化" aria-label="Permalink to “2. Pure ESM 和去打包工具化”">​</a></h2><p>ES6 定义了一套官方层面的模块系统，这一套系统比什么 CommonJS 之类的解决方案更标准、更现代。ES6 如今已经 10 多年了，Node.js 对 ESM 的支持当然越来越好。我记得去年我在 CommonJS 包里导入 ESM 的时候 Node.js 控制台还会报警告，现在新版已经没有了。</p><p>言归正传，就因为上述原因，有一种 Pure ESM 和去打包工具化的的潮流正在兴起，特别是在后端和现在的库领域。</p><p>Pure ESM 意味着，一个包在发布的时候已经完全不提供 CommonJS 版本，只有 ESM 版本，新版的 Node.js 对 ESM、CommonJS 的互操作已经足够好了，我们完全可以直接使用 ESM，而且 CommonJS 包确实在消亡了。</p><p>去打包工具化就意味着不再使用 Rollup/Webpack/tsup 之类的对后端和库进行打包，最多就用 TSC 之类的转译成 JS。后端当然使用打包的场景不多，但现在库领域也在慢慢减少对打包的依赖了。</p><p>库当初选择用打包工具，一是为了打包在一起压缩体积；二是，毕竟我同时生成 CommonJS、ESM、UMD，配置一下 Rollup 就完事了，很方便。但库绝大多数情况下本来就是要被打包进最终项目的，库本身再打包意义不大。</p><p>在这种 Pure ESM + 去打包工具化的场景下，我们就必须要遵守 ESM 规范了，导入模块的时候必须要写扩展名。在 tsconfig.json 里面，我们的 moduleResolution 要设置成 <code>node16</code> 或 <code>nodenext</code>。</p><p>但是在 TypeScript 5.7 之前，使用扩展名的写法真的很别扭。可能在以前，这不是个太大的问题，因为大家会选择用打包工具来打包一个库，而且当初很多后端虽然代码本身用 TS 写，但是编译的时候是 CommonJS 输出的，没必要遵守 ESM 规范。但是，现在新趋势已经有了，TypeScript 迫切需要解决这个问题。</p><h2 id="_3-以前是需要在-ts-里面写-js-后缀" tabindex="-1">3. 以前是需要在 TS 里面写 .js 后缀 <a class="header-anchor" href="#_3-以前是需要在-ts-里面写-js-后缀" aria-label="Permalink to “3. 以前是需要在 TS 里面写 .js 后缀”">​</a></h2><p>TypeScript 5.7 之前坚持比较原教旨的设计，不希望介入太多运行时逻辑，通俗来说就是：</p><blockquote><p>我只是一个类型检查、LSP 和转译工具，扩展名这一块不是我负责。</p></blockquote><p>可能有点像下面的一个古代笑话：</p><blockquote><p>一人前去观武场，飞箭不小心伤到了他，他请外科医生去帮他治疗。医生说：“这很简单”，就把外截的箭杆锯掉了，之后向病人索要报酬。病人问：“里面的怎么办？”，医生说：“这是内科的事。”</p></blockquote><p>所以在 <code>nodenext</code> 下，我们当时为了在一个 TS 模块里面引入另一个 TS 模块，就必须写成下面这样：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// foo.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// index.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { foo } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./foo.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>你看，这里明明是 <code>foo.ts</code> 文件，我们却要写成 <code>./foo.js</code>，这就很别扭。</p><p>如果你强行写成 <code>import { foo } from &quot;./foo.ts&quot;</code>，反而会出现问题。</p><p>就算你在 tsconfig.json 里面配置了 <code>allowImportingTsExtensions</code>，但因为没有重写后缀，运行的时候还是会报错。</p><h2 id="_4-rewriterelativeimportextensions-解决的问题" tabindex="-1">4. rewriteRelativeImportExtensions 解决的问题 <a class="header-anchor" href="#_4-rewriterelativeimportextensions-解决的问题" aria-label="Permalink to “4. rewriteRelativeImportExtensions 解决的问题”">​</a></h2><p>TypeScript 5.7 出现了 <code>rewriteRelativeImportExtensions</code> 这个配置项，解决了上面的问题。</p><p>要开始使用它，我们需要在 tsconfig.json 里面开启它：</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;compilerOptions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;allowImportingTsExtensions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 最好显式地开启这个选项</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;rewriteRelativeImportExtensions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>根据文档，当导入路径为相对路径（以 <code>./</code> 或 <code>../</code> 开头）、以 TypeScript 扩展名（如 <code>.ts</code>、<code>.tsx</code>、<code>.mts</code>）结尾，并且不是声明文件时，编译器会将该路径重写为对应的 JavaScript 扩展名（<code>.js</code>、<code>.jsx</code>、<code>.mjs</code>）。</p><p>也就是说，我们可以像下面这样写：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// foo.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// index.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { foo } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./foo.ts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>编译后，TSC 自动把 <code>./foo.ts</code> 重写成了 <code>./foo.js</code>：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// dist/foo.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// dist/index.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { foo } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./foo.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>这样我们在 TS 代码里面就可以很自然地使用 <code>.ts</code> 扩展名了，而不需要刻意去写 <code>.js</code>。</p><p>除 TSC 已经支持，Babel 在 7.23.0、SWC　在 1.13.7 之后也都开始支持这个配置项了。</p>`,42)])])}const g=i(n,[["render",p]]);export{c as __pageData,g as default};
