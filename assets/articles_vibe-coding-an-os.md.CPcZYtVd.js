import{_ as o,c as i,o as a,ag as r}from"./chunks/framework.lo-SgHyK.js";const h=JSON.parse('{"title":"我用 Rust Vibe Coding 了一个操作系统，然而","description":"","frontmatter":{},"headers":[],"relativePath":"articles/vibe-coding-an-os.md","filePath":"articles/vibe-coding-an-os.md","lastUpdated":1768628240000}'),p={name:"articles/vibe-coding-an-os.md"};function d(t,e,n,c,s,l){return a(),i("div",null,[...e[0]||(e[0]=[r('<h1 id="我用-rust-vibe-coding-了一个操作系统-然而" tabindex="-1">我用 Rust Vibe Coding 了一个操作系统，然而 <a class="header-anchor" href="#我用-rust-vibe-coding-了一个操作系统-然而" aria-label="Permalink to “我用 Rust Vibe Coding 了一个操作系统，然而”">​</a></h1><h2 id="_0-前言" tabindex="-1">0. 前言 <a class="header-anchor" href="#_0-前言" aria-label="Permalink to “0. 前言”">​</a></h2><p>今天是 2026 年 1 月 16日，昨天还是前天看到 Cursor 团队的一个人说用了一周时间用 Vibe Coding 搓了个浏览器（<code>wilsonzlin/fastrender</code>），我们的很多“AI 布道师”们也在狂欢，说，这下 AI 连写浏览器都行了。</p><p>Vibe Coding 布道师们不断地告诉你，现在既然连浏览器都搞出来了，AI 已经无所不能了，你作为程序员可以完蛋了。他们的隐含主张是：你只要有想法、会打字，就能让 AI 帮你写出任何软件，甚至有人说，AI 时代，代码可以作为一个日抛的一次性用品存在，如果有重大需求更改，AI 再写一个就是了。</p><p>好，Vibe Coding 个浏览器，那我搓一个操作系统可不可以？</p><p>于是我建了个仓库，写了提示词，开始 Vibe Coding。我定一个小目标，实现一个 DOS 吧，我们就用 FreeDOS 作为参考，毕竟人家是开源的，我的这个 DOS 就叫 VibeDOS 好了。</p><p>当看到我的 DOS 运行在黑底白字的屏幕上，敲入 <code>DIR</code> 还能列出文件时，是不是有种“哇，AI 懂操作系统开发！”的感觉？</p><p>是这样吗？当然不是。我还是亲眼戳穿这个魔术比较好。</p><h2 id="_1-并没有什么操作系统" tabindex="-1">1. 并没有什么操作系统 <a class="header-anchor" href="#_1-并没有什么操作系统" aria-label="Permalink to “1. 并没有什么操作系统”">​</a></h2><p>这个就是个海市蜃楼。AI 其实在做完形填空。在提示词目录下，有一个名为 <code>dont-do.instructions.md</code> 的文件，里面有一条我（人类）写死的铁律：</p><blockquote><p>绝对禁止：调用 <code>ExitBootServices()</code></p></blockquote><p>如果你懂一些操作系统的知识你会知道这意味着什么，只要不调用这个函数，你就根本没有接管硬件，那就不是真正的操作系统。</p><p>真正的操作系统开发需要从内核开始写起。而我做的 VibeDOS，实际上是一个 UEFI 应用程序。是 UEFI 固件帮我管理了内存，是 UEFI 帮我挂载了 FAT 文件系统，是 UEFI 帮我处理了键盘输入。</p><p>VibeDOS 就像是一个寄生虫，寄生在主板固件这个宿主上。</p><p>所谓的“Vibe Coding 一个操作系统”，从技术本质上讲，只是写了一个运行在裸机环境下的控制台应用程序。AI 并没有解决任何底层的硬核难题，是我通过架构决策（禁止 <code>ExitBootServices</code>），巧妙地避开了所有难题。</p><p>但这正是 Vibe Coding。</p><p>在这个语境下，“操作系统”不再是一个计算机科学名词，而是一种用户体验。当屏幕亮起，出现命令行提示符，你能输入指令，能看到反馈，甚至能跑个贪吃蛇——对坐在屏幕前的人来说，这就是一个 OS。</p><p>Andrej Karpathy 在定义 Vibe Coding 时曾说过，其核心在于“忘记代码的存在”。</p><p>这正是 Vibe Coding 的哲学：它主张不看细节，只看结果；不问出身，只问体验。</p><p>我并没有让 AI 去造轮子，而是让它去造驾驶体验。既然 UEFI 已经铺好了路，为什么非要假装自己是在铺路呢？</p><p>Vibe Coding 的精髓不在于苦大仇深地死磕底层，而在于用最省力的方式，把那个复古的、黑底白字的感觉给做出来。因为：</p><blockquote><p>如果它看起来像鸭子、游泳像鸭子、叫声像鸭子，那么它可能就是只鸭子。</p></blockquote><p>但是，虽然是在 UEFI 上的应用程序，但是要让行为比拟 FreeDOS，还是有难度的，我是怎么做到的呢？</p><h2 id="_2-ai-的本质" tabindex="-1">2. AI 的本质 <a class="header-anchor" href="#_2-ai-的本质" aria-label="Permalink to “2. AI 的本质”">​</a></h2><p>在这次开发 Shell 的内置命令时，AI 的表现惊人地好。它知道各种 DOS 的古怪行为，比如路径怎么解析、通配符怎么处理。</p><p>是它“理解”了 DOS 吗？否。请看 <code>.github/instructions/freedos-reference.instructions.md</code>。</p><p>在这个文件里，我明确告诉 AI：</p><blockquote><p>“编写代码时必须参考 FreeDOS 的实现逻辑...命令的输入输出格式应与 FreeDOS 保持一致...参考 FreeDOS 对边界情况的处理方式...”</p></blockquote><p>代码库下面我设置了一个 Git Submodule，把 FreeDOS 的内核和命令解释器的代码弄了下来，喂给 AI。AI 本质上是负责理解 FreeDOS 的逻辑，然后转换成 Rust 实现。</p><p>说到这里，有人说，哎哟你这不就是照本宣科吗？</p><p>对啊，我是照本宣科，可是 Transformer 模型的本质不就是照本宣科吗？它的底层原理我认为没有必要再说一次了。</p><p>如果我让它发明一种从未存在过的操作系统命令，它会胡言乱语。它之所以在 VibeDOS 上表现出色，仅仅是因为 DOS 是知名的计算机历史上的考古遗迹，而且，我给它喂了 FreeDOS 的代码。</p><p>代码库里可以说，从量算的话，几乎 99% 都是 AI 写的。</p><p>有人说，客观上，VibeDOS 开发工作都不是你做的，你确实被取代了。</p><p>可是呢？</p><h2 id="_3-我是剩下的-1-但这-1-决定了-99-。" tabindex="-1">3. 我是剩下的 1%，但这 1% 决定了 99%。 <a class="header-anchor" href="#_3-我是剩下的-1-但这-1-决定了-99-。" aria-label="Permalink to “3. 我是剩下的 1%，但这 1% 决定了 99%。”">​</a></h2><p>VibeDOS 项目的灵魂，并不在 <code>src</code> 目录里，而是在 <code>instructions</code> 目录下的一堆 Markdown 文件里。</p><p>里面的一堆指令是我写的，我告诉 AI，哪些要做，哪些不要做。虽然我对 UEFI Rust 编程几乎没有太多了解，但我还是像我刚做程序员的时候一样，事先从相关文档里做了不少功课，然后整理了些指令，喂给 AI。</p><p>用个比喻来说，</p><blockquote><p>AI 就像是一个打字速度飞快、精通语法但毫无常识的实习生。而这一堆 Markdown 文件，是拥有多年经验的架构师写给实习生的详细设计文档。</p></blockquote><p>VibeDOS 项目之所以能成，是因为 Tech Spec 写得好，而不是因为实习生打字快。Vibe Coding 的本质，就是极高强度的提示词工程，这些，离不开人的思考，而且这是人类的所擅长的但 AI 不擅长的。</p><p>虽然我之前也说过，我确实不熟悉 UEFI Rust 的 API 细节，从没写过一行 uefi-rs 代码。但我知道操作系统启动的基本原理，知道“禁止 ExitBootServices”意味着什么，知道该拿 FreeDOS 当参考（我以前也是个 Retro 爱好者，玩过 DOS）。这些判断力不是看两篇教程就能获得的——它来自多年踩坑的积累。</p><p>如果你不信，找一个完全没有编程经验的人，给他同样的工具，让他 Vibe Coding 一个操作系统试试。他连 ExitBootServices 是什么都不知道，又怎么知道要禁止它？</p><h3 id="_3-1-我又看了眼-wilsonzlin-fastrender" tabindex="-1">3.1 我又看了眼 <code>wilsonzlin/fastrender</code> <a class="header-anchor" href="#_3-1-我又看了眼-wilsonzlin-fastrender" aria-label="Permalink to “3.1 我又看了眼 wilsonzlin/fastrender”">​</a></h3><p>其实印证了我的观点。这个里面也是写了一堆提示词约束。</p><p>特别是 <code>docs/research/servo-layout-architecture.md</code>，还说了：</p><blockquote><p>Servo&#39;s layout architecture represents 15+ years of browser engineering experience distilled into a modern Rust codebase.</p></blockquote><p>这证明了什么？人类花时间研究其他浏览器引擎，提炼出架构模式，然后写成文档喂给 AI。 AI 做的只是把这一堆研究翻译成了代码，和我喂 FreeDOS 代码没差。</p><p>所以 Vibe Coding 的真相就是：把&quot;为什么这么做&quot;的人类知识，用 Markdown 文档的形式系统化地喂给 AI。AI 只是一个机械执行你的指令的工具。那些 <code>.instructions.md</code>、<code>philosophy.md</code>、<code>AGENTS.md</code>，才是项目真正的源代码。</p><h2 id="_4-话说回来" tabindex="-1">4. 话说回来 <a class="header-anchor" href="#_4-话说回来" aria-label="Permalink to “4. 话说回来”">​</a></h2><p>写代码，或者说，把脑袋里的想法变成代码，这是程序员给人最直观的职责。但是，这就像一枚鸡蛋一样，蛋壳下面才是最重要的。</p><p>我觉得在现在我们可以大方地承认，如果只是“将想法转换成代码”，那 AI 确实做的不错。程序员的价值，从来不在于把想法变成代码的速度，而在于有没有那个想法。哪怕是像我这样对 UEFI 编程不熟的人，只要肯花时间研究、肯思考边界条件，就能写出让 AI 正确执行的指令。这种能力，AI 没有。</p><p>真正的软件工程还充满了未知解：未知的硬件 Bug、未知的并发竞争、未知的业务逻辑冲突、出人意料的边缘条件。这并不是写一堆 Markdown 提示词能解决的，提示词只能解决已知解，面对未知解，我认为，AI 目前还远远不够格。</p><p>我不预测未来。也许明年 AI 就能自己推导出这些架构决策。但今天，2026 年 1 月，事实是它还做不到。那些告诉你“程序员已经完蛋了”的人，说的是现在，我反驳的也是现在。</p><h2 id="_5-写在最后" tabindex="-1">5. 写在最后 <a class="header-anchor" href="#_5-写在最后" aria-label="Permalink to “5. 写在最后”">​</a></h2><p>我的 VibeDOS 代码也放在了 GitHub，作为本文的论据之一，一些想法也在里面，<code>narukeu/vibedos-demo</code>，欢迎大家去看看，基于 WTFPL 许可证。</p>',56)])])}const u=o(p,[["render",d]]);export{h as __pageData,u as default};
