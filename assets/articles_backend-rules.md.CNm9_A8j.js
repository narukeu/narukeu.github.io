import{_ as i,c as l,o as s,ag as a}from"./chunks/framework.lo-SgHyK.js";const g=JSON.parse('{"title":"后端项目开发规范（通用）","description":"","frontmatter":{},"headers":[],"relativePath":"articles/backend-rules.md","filePath":"articles/backend-rules.md","lastUpdated":1763732674000}'),o={name:"articles/backend-rules.md"};function d(t,e,n,r,c,h){return s(),l("div",null,[...e[0]||(e[0]=[a(`<h1 id="后端项目开发规范-通用" tabindex="-1">后端项目开发规范（通用） <a class="header-anchor" href="#后端项目开发规范-通用" aria-label="Permalink to “后端项目开发规范（通用）”">​</a></h1><p>本文档为后端项目提供了一套通用的开发规范，旨在提升代码质量、可维护性与团队协作效率。本规范独立于具体语言和框架，适用于各类后端技术栈。</p><p>当前后端项目优先选用 <code>PostgreSQL</code> 作为数据库，因此数据类型及 SQL 相关规范均以此为基准。</p><h2 id="_1-架构与设计原则" tabindex="-1">1. 架构与设计原则 <a class="header-anchor" href="#_1-架构与设计原则" aria-label="Permalink to “1. 架构与设计原则”">​</a></h2><h3 id="_1-1-项目结构" tabindex="-1">1.1. 项目结构 <a class="header-anchor" href="#_1-1-项目结构" aria-label="Permalink to “1.1. 项目结构”">​</a></h3><p>应根据所使用的技术栈，采用社区推荐的项目结构。确保代码模块化、职责单一，便于维护和扩展。</p><ul><li>项目必须采用清晰的分层结构，至少拆分为对外暴露接口的 <code>Controller</code> 层和承载业务逻辑的 <code>Service</code> 层，避免在 <code>Controller</code> 中直接编写复杂业务代码或数据访问逻辑。</li><li>关于 <code>Controller</code> 和 <code>Service</code> 层具体如何命名和组织，可参考所使用语言和框架的最佳实践。</li><li><code>Service</code> 层必须遵循“接口先行”原则：先定义接口，再编写实现类/实现结构体。</li><li>对于 Go 等无原生类与接口概念的语言，可通过“接口类型 + 结构体”的方式实现类似的分层。</li><li>代码文件和目录结构应按业务功能进行划分，而非简单按技术层次划分，确保模块边界清晰、易于维护和重构。</li><li>必须建立 <code>common</code> 目录，用于存放全局异常处理、中间件、工具函数等公共代码。</li></ul><h4 id="_1-1-1-模块常量-路由前缀" tabindex="-1">1.1.1. 模块常量（路由前缀） <a class="header-anchor" href="#_1-1-1-模块常量-路由前缀" aria-label="Permalink to “1.1.1. 模块常量（路由前缀）”">​</a></h4><p>为提升路由管理的一致性并避免硬编码，建议为各路由模块定义路由前缀常量。</p><ul><li><strong>定义位置</strong>：在模块目录下的常量文件（如 <code>constants</code>）中定义。</li><li><strong>层级组合</strong>：子模块路由应拼接在父模块前缀之后，形成层级化结构。</li><li><strong>作用域限制</strong>：该常量作用域限定于模块内部，不应向外暴露。</li><li><strong>版本集成</strong>：路由前缀应与 API 版本号结合，构成如 <code>/v1/system/dict</code> 的完整路径。</li></ul><h3 id="_1-2-对象定义" tabindex="-1">1.2. 对象定义 <a class="header-anchor" href="#_1-2-对象定义" aria-label="Permalink to “1.2. 对象定义”">​</a></h3><p>根据不同场景，后端项目的数据对象可分为以下几类：</p><ul><li><strong>数据模型 (Data Model)</strong>：与数据库表结构一一对应的代码对象，亦称实体（Entity），本规范中统一称为 <code>Model</code>。 <ul><li><code>Model</code> 用于数据持久化操作。例如，用户表对应的模型可命名为 <code>User</code>。原则上，业务模型应继承基础模型 <code>BaseModel</code>（详见后续章节）。</li><li>若某些表（如配置表、关联表）无需公共字段，则可不继承 <code>BaseModel</code>。</li></ul></li><li><strong>DTO (Data Transfer Object)</strong>：用于层间（如客户端与服务端）数据传输的对象，通常作为 API 的输入参数。DTO 可命名为 <code>CreateUserDTO</code>。为复用公共字段，可定义 <code>BaseDTO</code> 供其他 DTO 继承，其结构可参考 <code>BaseModel</code>。在 <code>Go</code> 等无类语言中，可以叫 <code>Request</code>。</li><li><strong>VO (View Object)</strong>：服务端返回给客户端的视图层对象。若其结构与 DTO 相同，可复用。命名方式可为 <code>FindListVO</code>。在 Go 等无类语言中，可以叫 <code>Response</code>。</li></ul><p>对于 Go 等无类概念的语言，上述对象均使用结构体（Struct）定义。对于继承，Go 可通过结构体嵌套实现；其他语言若不支持嵌套，可采用组合模式。</p><h2 id="_2-编码规范" tabindex="-1">2. 编码规范 <a class="header-anchor" href="#_2-编码规范" aria-label="Permalink to “2. 编码规范”">​</a></h2><h3 id="_2-1-通用准则" tabindex="-1">2.1. 通用准则 <a class="header-anchor" href="#_2-1-通用准则" aria-label="Permalink to “2.1. 通用准则”">​</a></h3><ul><li><strong>代码自解释</strong>：力求代码意图清晰，减少不必要的注释。推荐使用长的变量名和函数名，以提升可读性。</li><li><strong>时间处理</strong>：所有时间数据在存储、处理和传输时，必须统一使用 <code>UTC</code> 时间，以规避时区问题。</li><li><strong>参数命名</strong>：回调函数或方法签名中的参数名应具象化，避免使用无意义的单字母变量（如 <code>i</code>, <code>v</code>, <code>e</code>）。</li></ul><h3 id="_2-2-注释规范" tabindex="-1">2.2. 注释规范 <a class="header-anchor" href="#_2-2-注释规范" aria-label="Permalink to “2.2. 注释规范”">​</a></h3><p>仅在必要时添加注释。注释应聚焦于解释“为何如此”（Why），而非“这是什么”（What），重点阐述代码背后的设计思想、业务背景或特殊考量。注释必须使用中文。</p><h2 id="_3-api-设计规范" tabindex="-1">3. API 设计规范 <a class="header-anchor" href="#_3-api-设计规范" aria-label="Permalink to “3. API 设计规范”">​</a></h2><h3 id="_3-1-http-方法与版本管理" tabindex="-1">3.1. HTTP 方法与版本管理 <a class="header-anchor" href="#_3-1-http-方法与版本管理" aria-label="Permalink to “3.1. HTTP 方法与版本管理”">​</a></h3><ul><li><strong>HTTP 方法</strong>：为简化客户端和网关实现，API 仅使用 <code>GET</code> 和 <code>POST</code>。不使用 <code>PUT</code>, <code>DELETE</code>, <code>PATCH</code> 等方法。 <ul><li><code>GET</code>：用于请求数据，参数通过 URL 查询字符串传递。</li><li><code>POST</code>：用于提交数据（创建/更新）或执行需要复杂参数的查询。</li></ul></li><li><strong>API 版本管理</strong>：所有 API 必须包含版本标识。推荐采用 URL 路径进行版本控制（例如 <code>/v1/system/user/findAll</code>）。当发生不兼容变更时，应发布新版本（如 <code>v2</code>），并为旧版本保留一段过渡期。</li></ul><h3 id="_3-2-基础接口命名" tabindex="-1">3.2. 基础接口命名 <a class="header-anchor" href="#_3-2-基础接口命名" aria-label="Permalink to “3.2. 基础接口命名”">​</a></h3><p>为保持项目结构的一致性与可预测性，所有资源的 CRUD 操作应遵循以下标准命名。控制器（Controller）与服务（Service）层的方法名必须保持一致。</p><ul><li><code>findOne</code>：获取单个资源。</li><li><code>findList</code>：获取资源列表（分页）。</li><li><code>findAll</code>：获取所有资源列表（不分页，可选）。</li><li><code>findTree</code>：获取树形结构资源列表（分页），入参规范与 <code>findList</code> 相同。<code>findList</code> 和 <code>findAll</code> 仅返回扁平结构。</li><li><code>findTreeAll</code>：获取所有资源的树形结构列表（不分页），入参规范与 <code>findAll</code> 相同。</li><li><code>create</code>：创建单个资源。</li><li><code>createMany</code>：批量创建资源（可选）。</li><li><code>update</code>：更新单个资源。</li><li><code>delete</code>：永久删除单个资源。</li><li><code>deleteMany</code>：批量永久删除资源（可选）。</li><li><code>remove</code>：逻辑删除（软删除）单个资源。</li><li><code>removeMany</code>：批量逻辑删除资源（可选）。</li><li><code>restore</code>：恢复被逻辑删除的资源。</li><li><code>restoreMany</code>：批量恢复被逻辑删除的资源（可选）。</li><li><code>count</code>：获取资源总数（可选）。</li><li><code>findWithDeleted</code>：返回全部数据（包含未删除与已软删除的数据，可选，分页）。</li><li><code>findWithDeletedAll</code>：返回全部数据（包含未删除与已软删除的数据，可选，不分页）。</li><li><code>findOnlyDeleted</code>：返回仅已被软删除的数据（分页）。</li><li><code>findOnlyDeletedAll</code>：仅返回已被软删除的数据（可选，不分页）。</li></ul><h3 id="_3-3-查询接口规范" tabindex="-1">3.3. 查询接口规范 <a class="header-anchor" href="#_3-3-查询接口规范" aria-label="Permalink to “3.3. 查询接口规范”">​</a></h3><h4 id="_3-3-1-复杂查询" tabindex="-1">3.3.1. 复杂查询 <a class="header-anchor" href="#_3-3-1-复杂查询" aria-label="Permalink to “3.3.1. 复杂查询”">​</a></h4><ul><li><code>findList</code>、<code>findAll</code>、<code>findTree</code>、<code>findTreeAll</code> 接口应使用 <code>POST</code> 方法，允许客户端通过请求体（Request Body）以 JSON 格式传递复杂的过滤和排序条件。</li></ul><h4 id="_3-3-2-查询软删除数据-with-only-deleted" tabindex="-1">3.3.2. 查询软删除数据 (With / Only Deleted) <a class="header-anchor" href="#_3-3-2-查询软删除数据-with-only-deleted" aria-label="Permalink to “3.3.2. 查询软删除数据 (With / Only Deleted)”">​</a></h4><ul><li>标准查询接口仅返回未被软删除的数据（<code>deleted_time IS NULL</code>），为了方便起见，应当提供额外的接口支持软删除数据。</li><li>这些接口的入参、排序和分页规则与标准查询接口保持一致。可以复用标准查询的 DTO（Request）和 VO（Response）。</li></ul><h4 id="_3-3-3-分页与排序参数" tabindex="-1">3.3.3. 分页与排序参数 <a class="header-anchor" href="#_3-3-3-分页与排序参数" aria-label="Permalink to “3.3.3. 分页与排序参数”">​</a></h4><ul><li>分页参数通过 URL 查询参数传递： <ul><li><code>currentPage</code>：当前页码，默认值为 <code>1</code>。</li><li><code>pageSize</code>：每页记录数，默认值为 <code>20</code>。</li></ul></li><li>对于 <code>findList</code> 等接口，筛选条件应通过请求体（Request Body）以 JSON 格式传递。</li></ul><p>由于默认按创建时间倒序排序，通常无需传递排序参数。若需自定义排序，可在 URL Query 中传递 <code>sortBy</code> 和 <code>sortOrder</code> 参数。</p><ul><li><code>sortBy</code>：指定排序字段。</li><li><code>sortOrder</code>：指定排序顺序，<code>0</code> 为降序，<code>1</code> 为升序，默认值为 <code>0</code>。</li><li><code>sortOrder</code> 可单独传递，此时表示对默认的 <code>created_time</code> 字段进行排序。</li></ul><p><code>pageSize</code> 上限为 <code>150</code>，超出则报错。</p><p>分页实现可直接使用 ORM（如 <code>Mybatis-Plus</code>、<code>Gorm</code>）的内置功能；若无，则需自行封装统一的分页逻辑。</p><h5 id="_3-3-3-1-分页方式" tabindex="-1">3.3.3.1. 分页方式 <a class="header-anchor" href="#_3-3-3-1-分页方式" aria-label="Permalink to “3.3.3.1. 分页方式”">​</a></h5><h5 id="_3-3-3-1-1-折衷-offset-与性能的方案" tabindex="-1">3.3.3.1.1. 折衷 <code>OFFSET</code> 与性能的方案 <a class="header-anchor" href="#_3-3-3-1-1-折衷-offset-与性能的方案" aria-label="Permalink to “3.3.3.1.1. 折衷 OFFSET 与性能的方案”">​</a></h5><p>项目对于常规需求还是采用 <code>OFFSET</code> 分页方式，但是针对 <code>OFFSET</code> 带来的性能问题，做出下面的调整：</p><ul><li>默认限制客户端允许查询的最大页面数为 <code>350</code>，超过则报错，提示使用更精确的过滤条件缩小结果集。</li><li>当表数据量较大（如超过 100 万行）且无法避免深度分页时，<strong>禁止</strong>直接对主表进行 <code>OFFSET</code> 查询。<strong>必须</strong>采用“延迟关联”策略：先通过覆盖索引查询出目标页的主键 ID 列表，再通过 ID 列表回表查询完整数据。</li></ul><h5 id="_3-3-3-1-2-游标分页" tabindex="-1">3.3.3.1.2. 游标分页 <a class="header-anchor" href="#_3-3-3-1-2-游标分页" aria-label="Permalink to “3.3.3.1.2. 游标分页”">​</a></h5><p>如果上述方法均不适用，可针对特定接口实现游标分页，以提升深度分页性能。在涉及到具体业务时另行说明。 实行游标分页接口的入参和响应结构需单独定义，不得与标准分页接口混用。</p><h4 id="_3-3-4-批量-id-入参对象" tabindex="-1">3.3.4. 批量 ID 入参对象 <a class="header-anchor" href="#_3-3-4-批量-id-入参对象" aria-label="Permalink to “3.3.4. 批量 ID 入参对象”">​</a></h4><p>对于仅需一组资源 ID 的批量操作，建议统一使用“批量 ID 入参对象”，以提升接口的一致性与可读性。建议定义为公共 <code>DTO</code>，命名为 <code>ByIdsDTO</code>。</p><ul><li><strong>结构约定（推荐）</strong><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;ids&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;a348f08c-8c9e-4bac-95bd-146750cfb064&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;6f7d8b9c-1234-4abc-9def-0123456789ab&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><strong>适用场景</strong>：<code>deleteMany</code>、<code>removeMany</code>、<code>restoreMany</code>、<code>updateMany</code> 等仅凭 ID 即可完成的批量接口。</li><li><strong>校验与约束</strong><ul><li><code>ids</code> 必须为非空数组，元素类型与主键类型一致（默认 <code>UUID</code>，推荐 <code>uuidv7</code>）。</li><li>元素应去重，且禁止 <code>null</code> 或空字符串。可设置最大长度（如 100-500），视业务与性能而定。</li><li>ID 格式必须合法。对于非 UUID 主键，应采用相应的校验规则。</li></ul></li><li><strong>行为约定</strong><ul><li>若任一 ID 不存在，默认应整体失败并返回明确的业务错误。也可按需提供“跳过不存在”模式，但需在接口文档中声明。</li><li>操作应与权限控制联动，仅当调用者具备相应权限时方可执行。</li><li>日志审计应记录请求 ID、操作人、影响的资源数量及样本 ID。</li></ul></li></ul><h3 id="_3-4-响应结构" tabindex="-1">3.4. 响应结构 <a class="header-anchor" href="#_3-4-响应结构" aria-label="Permalink to “3.4. 响应结构”">​</a></h3><h4 id="_3-4-1-统一响应体" tabindex="-1">3.4.1. 统一响应体 <a class="header-anchor" href="#_3-4-1-统一响应体" aria-label="Permalink to “3.4.1. 统一响应体”">​</a></h4><p>所有 API 响应都应遵循统一的 JSON 结构，以便客户端进行标准化处理。</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;businessCode&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 业务状态码：0 表示成功，非 0 表示具体错误类型。注意：这不是 HTTP 状态码。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // HTTP 状态码由 Axios 等库自动处理，后端无需在响应体中返回。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;isSuccess&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 操作是否成功，错误时为 false。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;操作成功！&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 结果消息，错误时返回错误信息。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;a348f08c-8c9e-4bac-95bd-146750cfb064&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;示例数据&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回的数据，错误时为 null。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;timestamp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2025-11-05T07:44:01.608Z&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ISO 8601 格式的时间戳。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;errors&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 可选，详细错误信息列表，用于复杂业务错误场景。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>响应头应包含 <code>X-Request-ID</code>，用于请求追踪。</li></ul><h4 id="_3-4-2-分页响应结构" tabindex="-1">3.4.2. 分页响应结构 <a class="header-anchor" href="#_3-4-2-分页响应结构" aria-label="Permalink to “3.4.2. 分页响应结构”">​</a></h4><p>对于分页接口，<code>data</code> 字段应采用以下结构，并封装为统一的 VO。</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;total&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 总记录数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;currentPage&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 当前页码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;pageSize&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 每页记录数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;records&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 当前页的记录数组</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_3-4-3-businesscode-状态码" tabindex="-1">3.4.3. businessCode 状态码 <a class="header-anchor" href="#_3-4-3-businesscode-状态码" aria-label="Permalink to “3.4.3. businessCode 状态码”">​</a></h4><ul><li><code>0</code>：操作成功</li><li><code>1xxx</code>：系统级错误（如数据库连接失败、超时）</li><li><code>2xxx</code>：认证/鉴权失败</li><li><code>3xxx</code>：参数错误（如缺少必填项、格式错误）</li><li><code>4xxx</code>：业务逻辑错误（包括权限不足导致的接口访问失败，例如 <code>findWithDeleted</code> / <code>findOnlyDeleted</code> 等）</li><li><code>5xxx</code>：数据库相关错误</li><li><code>9xxx</code>：未知错误</li></ul><h3 id="_3-5-文件处理" tabindex="-1">3.5. 文件处理 <a class="header-anchor" href="#_3-5-文件处理" aria-label="Permalink to “3.5. 文件处理”">​</a></h3><ul><li>文件下载应支持流式传输和断点续传。</li></ul><h2 id="_4-数据持久化规范" tabindex="-1">4. 数据持久化规范 <a class="header-anchor" href="#_4-数据持久化规范" aria-label="Permalink to “4. 数据持久化规范”">​</a></h2><h3 id="_4-1-数据库-postgresql" tabindex="-1">4.1. 数据库（PostgreSQL） <a class="header-anchor" href="#_4-1-数据库-postgresql" aria-label="Permalink to “4.1. 数据库（PostgreSQL）”">​</a></h3><h4 id="_4-1-1-表与字段" tabindex="-1">4.1.1. 表与字段 <a class="header-anchor" href="#_4-1-1-表与字段" aria-label="Permalink to “4.1.1. 表与字段”">​</a></h4><ul><li><strong>命名规范</strong>：表名和列名必须采用下划线命名法（<code>snake_case</code>），例如 <code>user_profiles</code>。</li><li><strong>数据类型</strong>： <ul><li><strong>时间类型</strong>：统一使用带时区的 <code>timestamptz</code> 类型，且时区必须为 <code>UTC</code>。</li><li><strong>精确数值</strong>：对于金额、汇率等需高精度计算的字段，必须使用 <code>decimal</code> 类型。</li><li><strong>大文本</strong>：对于长度不定的文本，应使用 <code>text</code> 类型。</li></ul></li><li><strong>公共字段</strong>：所有业务相关的数据表都应包含一组标准公共字段，以记录元数据。 <ul><li><code>id</code> (主键): <code>UUID</code> 类型。</li><li><code>created_time</code> (创建时间)：<code>timestamptz</code> 类型，该字段默认和主键 <code>id</code> 建复合索引。</li><li><code>updated_time</code> (更新时间)：<code>timestamptz</code> 类型。</li><li><code>deleted_time</code> (软删除时间)：可选，<code>timestamptz</code> 类型，<code>NULL</code> 表示未删除。</li><li><code>created_by</code> (创建者)：可选，<code>UUID</code> 类型，记录创建者 ID。<code>NULL</code> 表示由系统创建。</li><li><code>updated_by</code> (更新者)：可选，<code>UUID</code> 类型，记录更新者 ID。<code>NULL</code> 表示由系统更新。</li><li><code>deleted_by</code> (删除者)：可选，<code>UUID</code> 类型，记录删除者 ID。<code>NULL</code> 表示由系统删除。</li><li><code>status</code> (状态)：<code>varchar(32)</code> 类型，<code>0</code> 代表无效，<code>1</code> 代表有效。</li><li><code>remark</code> (备注)：<code>text</code> 类型。</li><li><code>is_system_reserved</code> (系统保留)：<code>boolean</code> 类型，标识是否为系统保留数据，默认为 <code>false</code>，如果是，则不可删除。</li></ul></li><li><strong>主键</strong>：主键 ID 应使用 <code>uuidv7</code>。若数据库支持，可使用 <code>uuid_generate_v7()</code> 函数生成；否则，在应用层生成。</li><li><strong>模型定义</strong>：<code>BaseModel</code> 应包含上述公共字段，其他数据模型继承之。模型中必须显式定义这些字段，不依赖 ORM 的隐式功能。</li><li><strong>状态说明</strong>：<code>status</code> 字段表示资源自身的业务状态，与逻辑删除状态无关。逻辑删除通过 <code>deleted_time</code> 字段实现，两者职责分离。</li></ul><h4 id="_4-1-2-关系-relation" tabindex="-1">4.1.2. 关系 (Relation) <a class="header-anchor" href="#_4-1-2-关系-relation" aria-label="Permalink to “4.1.2. 关系 (Relation)”">​</a></h4><ul><li><strong>关系类型</strong>：应根据业务需求选择合适的关系类型（一对一、一对多、多对多），避免滥用多对多关系。</li><li><strong>不使用外键</strong>：为避免高并发写入场景下的性能瓶颈，不使用数据库外键约束。数据一致性由应用层逻辑保障。 <ul><li>由于不使用外键，应用层必须承担保障数据一致性的全部责任： <ul><li>关联写入操作必须置于事务中。</li><li>删除或更新关联数据前，必须检查是否存在依赖关系，防止产生孤立数据。</li><li>应定期运行数据完整性检查脚本，以发现并修复潜在的不一致问题。</li></ul></li></ul></li></ul><h4 id="_4-1-3-树形结构" tabindex="-1">4.1.3. 树形结构 <a class="header-anchor" href="#_4-1-3-树形结构" aria-label="Permalink to “4.1.3. 树形结构”">​</a></h4><ul><li><strong>实现方式</strong>：为保证性能，应尽可能通过 SQL 实现树结构的查询与操作，避免在应用层递归处理。若所用 ORM 提供成熟的树结构支持（包括节点筛选），亦可使用。</li><li><strong>子节点键名</strong>：统一使用 <code>children</code>。可建立一个基础树形 VO 供其他树形结构继承。</li><li><strong>基础树 VO</strong>：<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;children&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [],</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;parentId&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;父节点 ID&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 可选，根节点为 null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><strong>邻接表</strong>：对于结构简单的树（如系统菜单），可使用邻接表实现。</li><li><strong>闭包表</strong>：在以下场景中，应使用闭包表（Closure Table）实现树形结构： <ul><li>树的层级较深，且需频繁查询某节点的所有子孙。</li><li>需频繁移动节点（改变父节点）。</li><li>需高效查询节点的祖先路径。</li></ul></li></ul><h4 id="_4-1-4-查询与操作" tabindex="-1">4.1.4. 查询与操作 <a class="header-anchor" href="#_4-1-4-查询与操作" aria-label="Permalink to “4.1.4. 查询与操作”">​</a></h4><ul><li><strong>参数化查询</strong>：所有数据库查询都必须使用参数化查询（Prepared Statements），以从根本上杜绝 SQL 注入。</li><li><strong>避免 <code>SELECT *</code></strong>：查询时必须明确指定所需字段，以减少不必要的数据传输和数据库开销。</li><li><strong>避免 N+1 查询</strong>：严禁在循环中执行数据库查询。应通过 <code>IN</code> 查询或 <code>JOIN</code> 将多次查询合并为单次操作。</li><li><strong>复杂查询</strong>：对于涉及多表连接（JOIN）、聚合、子查询等复杂场景，推荐使用原生 SQL 或查询构建器，以保证代码的可读性与性能。</li></ul><h4 id="_4-1-5-事务-transaction" tabindex="-1">4.1.5. 事务 (Transaction) <a class="header-anchor" href="#_4-1-5-事务-transaction" aria-label="Permalink to “4.1.5. 事务 (Transaction)”">​</a></h4><ul><li><strong>原子性</strong>：任何涉及多个写操作的业务逻辑都必须封装在事务中，以保证操作的原子性。</li><li><strong>缩短事务时长</strong>：避免在事务中执行外部 API 调用、文件 I/O 等耗时操作，以减少锁竞争和数据库压力。</li><li><strong>隔离级别</strong>：默认为 <code>READ COMMITTED</code>。对一致性要求更高的读写流程，可提升至 <code>REPEATABLE READ</code>（需评估死锁与性能影响）。</li></ul><h4 id="_4-1-6-索引" tabindex="-1">4.1.6. 索引 <a class="header-anchor" href="#_4-1-6-索引" aria-label="Permalink to “4.1.6. 索引”">​</a></h4><ul><li>应当根据查询需求合理创建索引，以提升查询性能。</li></ul><h4 id="_4-1-7-数据库结构变更-migration" tabindex="-1">4.1.7. 数据库结构变更 (Migration) <a class="header-anchor" href="#_4-1-7-数据库结构变更-migration" aria-label="Permalink to “4.1.7. 数据库结构变更 (Migration)”">​</a></h4><ul><li><strong>禁用自动同步</strong>：生产环境中，必须禁用任何自动同步数据库结构的功能。</li><li><strong>迁移脚本</strong>：所有数据库结构变更（DDL）都必须通过迁移脚本管理。每个脚本应保证原子性与可回滚性。</li><li><strong>工具</strong>：Go、Java 等项目统一使用 <code>Flyway</code> 进行数据库迁移。对于 TypeORM 项目，简单场景可用其自带迁移工具，复杂场景仍推荐 <code>Flyway</code>。</li><li><strong>命名</strong>：Flyway 脚本命名格式为 <code>{时间}__V{版本号}__{描述}.sql</code>，例如 <code>2025_11_06_15_34__V1__create_user_table.sql</code>。</li></ul><h3 id="_4-2-缓存-redis" tabindex="-1">4.2. 缓存 (Redis) <a class="header-anchor" href="#_4-2-缓存-redis" aria-label="Permalink to “4.2. 缓存 (Redis)”">​</a></h3><p>对于使用 Redis 的项目，应遵循以下规范：</p><ul><li><strong>实例隔离</strong>：每个项目应使用独立的 Redis 实例和数据库（DB），避免数据混淆。不同环境应连接到不同的 Redis 服务器，防止开发环境误操作生产数据。</li><li><strong>连接管理</strong>：应使用连接池管理 Redis 连接，避免频繁创建和销毁。</li><li><strong>键命名</strong>：键名应以项目名称为前缀，例如 <code>myproject:user:captcha</code>。</li><li><strong>数据序列化</strong>：存储 JSON 等复杂数据时，应先序列化为字符串再存入，读取时反序列化，以保证兼容性。</li><li><strong>过期时间</strong>：缓存数据必须设置合理的过期时间（TTL），并引入随机抖动，防止大量缓存同时失效导致缓存雪崩。</li><li><strong>数据结构</strong>：根据业务场景选择合适的数据结构（String, Hash, List, Set, ZSet），避免滥用。</li><li><strong>批量操作</strong>：对于大量数据读写，应使用管道（Pipeline）或 <code>MGET</code> 等批量命令。</li><li><strong>优雅降级</strong>：当 Redis 不可用时，应能优雅降级而不影响核心业务。可回退至数据库查询，或使用本地缓存作为二级缓存。</li><li><strong>重试机制</strong>：应为网络抖动等临时性故障实现合理的重试机制（建议最多 3 次，采用指数退避策略）。</li><li><strong>安全</strong>： <ul><li>生产环境必须为 Redis 设置强密码，并通过环境变量配置。</li><li>Redis 应部署在内网，不应直接暴露到公网。</li></ul></li><li><strong>性能与资源</strong>： <ul><li>生产环境中严禁使用 <code>KEYS</code> 命令，应改用 <code>SCAN</code> 进行增量迭代。</li><li>应设置 <code>maxmemory</code> 限制，防止内存溢出。</li><li>避免存储过大的键值对（如 &gt;100KB）。大对象应拆分或存入对象存储，Redis 中仅保存索引。</li><li>对于可预见的热点数据（如秒杀商品），应在架构上优化，采用多级缓存或本地缓存，避免请求集中于单个 Key。</li></ul></li></ul><h2 id="_5-安全与鉴权" tabindex="-1">5. 安全与鉴权 <a class="header-anchor" href="#_5-安全与鉴权" aria-label="Permalink to “5. 安全与鉴权”">​</a></h2><h3 id="_5-1-鉴权与权限" tabindex="-1">5.1. 鉴权与权限 <a class="header-anchor" href="#_5-1-鉴权与权限" aria-label="Permalink to “5.1. 鉴权与权限”">​</a></h3><ul><li><strong>基础鉴权</strong>：使用 <code>JWT</code>。若项目需要，可引入 <code>OAuth2.0</code>。</li><li><strong>权限模型</strong>：后端项目应采用基于角色的访问控制（RBAC）模型。每个 API 方法都应映射到一个唯一的权限点。</li><li><strong>权限点命名</strong>：权限点标识符应与 API 方法名严格对应，以实现精细化控制。例如，<code>create</code> 方法对应 <code>create</code> 权限点。</li><li><strong>查询类接口权限</strong>： <ul><li>查看已删除数据的能力应被视为一项特殊权限，但通过独立接口实现（不再使用 <code>mode</code> 参数切换行为）。</li><li>如提供 <code>findWithDeleted</code> / <code>findWithDeletedAll</code> / <code>findOnlyDeleted</code> / <code>findOnlyDeletedAll</code> 等接口，应分别绑定独立权限点，命名规则与其他接口保持一致。</li><li><code>findAll</code> / <code>findWithDeletedAll</code> / <code>findOnlyDeletedAll</code> 等“不分页全量”接口，因可能返回大量数据，必须绑定独立的权限点，防止被滥用导致性能问题。</li></ul></li><li><strong>软删除权限</strong>： <ul><li><code>remove</code>/<code>removeMany</code>（软删除）和 <code>restore</code>/<code>restoreMany</code>（恢复）操作也必须有独立的权限点。</li></ul></li><li>后端项目应当有以下两种 Token： <ul><li><code>Access Token</code>：用于访问受保护的资源，生命周期较短。</li><li><code>Refresh Token</code>：用于刷新访问令牌，生命周期较长。</li></ul></li></ul><h3 id="_5-2-安全规范" tabindex="-1">5.2. 安全规范 <a class="header-anchor" href="#_5-2-安全规范" aria-label="Permalink to “5.2. 安全规范”">​</a></h3><ul><li><strong>密码存储</strong>：密码必须加盐，使用 <code>argon2</code>。</li><li><strong>输入校验</strong>：虽然客户端会进行输入校验，但后端必须对重要输入进行再校验。</li><li><strong>敏感数据</strong>：所有敏感数据（如密码、API 密钥等）在存储和传输过程中必须进行加密处理。严禁在日志或 API 响应中直接输出密码、密钥、身份证号等敏感信息。</li><li><strong>速率限制</strong>：对于登录、注册等敏感接口，应实现速率限制，防止暴力破解攻击。</li></ul><h2 id="_6-横切关注点" tabindex="-1">6. 横切关注点 <a class="header-anchor" href="#_6-横切关注点" aria-label="Permalink to “6. 横切关注点”">​</a></h2><h3 id="_6-1-配置管理" tabindex="-1">6.1. 配置管理 <a class="header-anchor" href="#_6-1-配置管理" aria-label="Permalink to “6.1. 配置管理”">​</a></h3><ul><li><strong>环境变量优先</strong>：所有配置项（如数据库凭证、API 密钥、服务端口等）应优先通过环境变量读取。</li><li><strong>配置文件</strong>：可以提供一个默认的配置文件，但不应将包含敏感信息的配置文件提交到版本控制系统中。</li><li><strong>环境分离</strong>：应为开发、测试、生产等不同环境提供独立的配置。</li></ul><h3 id="_6-2-日志规范" tabindex="-1">6.2. 日志规范 <a class="header-anchor" href="#_6-2-日志规范" aria-label="Permalink to “6.2. 日志规范”">​</a></h3><ul><li><strong>格式</strong>：采用结构化 JSON 日志，必须包含 <code>level</code>, <code>timestamp(UTC)</code>, <code>logger</code>, <code>message</code>, <code>requestId</code>, <code>userId</code>（若有）。</li><li><strong>级别</strong>：生产环境记录 <code>INFO</code> 及以上级别，本地开发可使用 <code>DEBUG</code>。</li><li><strong>安全</strong>：禁止在日志中输出密码、密钥、身份证号等敏感信息。</li><li><strong>管理</strong>：应实现日志采样与滚动策略，并使用 ELK、Cloud Logging 等工具进行集中收集。</li></ul><h3 id="_6-3-异常处理" tabindex="-1">6.3. 异常处理 <a class="header-anchor" href="#_6-3-异常处理" aria-label="Permalink to “6.3. 异常处理”">​</a></h3><ul><li><strong>封装数据库错误</strong>：严禁将原始的数据库错误信息直接暴露给客户端。</li><li><strong>统一处理</strong>：应通过全局异常处理机制捕获数据库异常，并将其转换为标准化的错误响应。</li><li><strong>记录日志</strong>：捕获异常时，必须记录详细的错误日志，以便于问题排查。</li></ul><h2 id="_7-开发与部署" tabindex="-1">7. 开发与部署 <a class="header-anchor" href="#_7-开发与部署" aria-label="Permalink to “7. 开发与部署”">​</a></h2><h3 id="_7-1-文档" tabindex="-1">7.1. 文档 <a class="header-anchor" href="#_7-1-文档" aria-label="Permalink to “7.1. 文档”">​</a></h3><ul><li><strong>API 文档</strong>：必须使用 OpenAPI (Swagger) 生成 API 文档。</li><li><strong>文档内容</strong>：每个接口都应包含清晰的描述、参数说明和响应示例。</li><li><strong>关键信息</strong>：必须标注接口的鉴权要求与所需权限点。为分页、树形结构、复杂过滤等提供示例。</li></ul><h3 id="_7-2-容器化" tabindex="-1">7.2. 容器化 <a class="header-anchor" href="#_7-2-容器化" aria-label="Permalink to “7.2. 容器化”">​</a></h3><p>若项目采用容器化部署，应遵循以下规范：</p><ul><li><strong>镜像优化</strong>：使用多阶段构建（Multi-stage builds）来优化镜像大小。</li><li><strong>配置</strong>：配置应通过环境变量传递，避免在镜像中硬编码。敏感配置应从密钥管理服务注入。</li><li><strong>安全</strong>：容器应以非 root 用户运行；文件系统应尽量设为只读，仅在必要时挂载可写目录。</li><li><strong>运行时</strong>： <ul><li><strong>优雅终止</strong>：应用必须能正确处理 <code>SIGTERM</code> 信号以实现优雅停机。</li><li><strong>时区同步</strong>：容器内部必须使用 UTC 时区。</li></ul></li></ul><h2 id="_8-通用业务规范" tabindex="-1">8. 通用业务规范 <a class="header-anchor" href="#_8-通用业务规范" aria-label="Permalink to “8. 通用业务规范”">​</a></h2><h3 id="_8-1-字典" tabindex="-1">8.1 字典 <a class="header-anchor" href="#_8-1-字典" aria-label="Permalink to “8.1 字典”">​</a></h3><ul><li>字典的值允许传入字符串和数字，所以在数据库中使用 <code>varchar(32)</code> 类型存储字典值。</li></ul>`,97)])])}const p=i(o,[["render",d]]);export{g as __pageData,p as default};
