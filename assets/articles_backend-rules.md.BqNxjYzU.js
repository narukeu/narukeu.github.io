import{_ as e,c as a,o as s,af as l}from"./chunks/framework.CkW8_0d0.js";const k=JSON.parse('{"title":"后端项目开发规范（通用）","description":"","frontmatter":{},"headers":[],"relativePath":"articles/backend-rules.md","filePath":"articles/backend-rules.md","lastUpdated":1762344463000}'),o={name:"articles/backend-rules.md"};function t(d,i,n,c,r,h){return s(),a("div",null,[...i[0]||(i[0]=[l(`<h1 id="后端项目开发规范-通用" tabindex="-1">后端项目开发规范（通用） <a class="header-anchor" href="#后端项目开发规范-通用" aria-label="Permalink to &quot;后端项目开发规范（通用）&quot;">​</a></h1><p>本文档旨在为所有后端项目提供一套通用的开发规范，确保代码质量、可维护性和团队协作效率。本规范是语言和框架无关的，适用于任何后端技术栈。</p><p>目前后端项目首要使用 <code>PostgreSQL</code> 作为数据库，因此数据类型和 SQL 相关的规范均基于 <code>PostgreSQL</code>。</p><h2 id="_1-编码规范" tabindex="-1">1. 编码规范 <a class="header-anchor" href="#_1-编码规范" aria-label="Permalink to &quot;1. 编码规范&quot;">​</a></h2><h3 id="_1-1-通用准则" tabindex="-1">1.1. 通用准则 <a class="header-anchor" href="#_1-1-通用准则" aria-label="Permalink to &quot;1.1. 通用准则&quot;">​</a></h3><ul><li><strong>代码自解释</strong>：力求代码本身就能清晰地表达其意图，减少不必要的注释。</li><li><strong>时间处理</strong>：所有时间数据在存储、处理和传输时，统一使用 <code>UTC</code> 时间，以避免时区问题。</li><li><strong>参数命名</strong>：回调函数或方法签名中的参数名应具有明确的描述性，避免使用无意义的单字母变量（如 <code>i</code>, <code>v</code>, <code>e</code> 等）。</li></ul><h4 id="代码划分" tabindex="-1">代码划分 <a class="header-anchor" href="#代码划分" aria-label="Permalink to &quot;代码划分&quot;">​</a></h4><p>应当以功能模块为单位划分代码文件和目录结构，确保每个模块职责单一，便于维护和扩展。</p><ul><li>要有 <code>common</code> 文件夹，存放公共代码，比如，全局异常处理、中间件、工具函数等。</li></ul><h3 id="_1-2-注释规范" tabindex="-1">1.2. 注释规范 <a class="header-anchor" href="#_1-2-注释规范" aria-label="Permalink to &quot;1.2. 注释规范&quot;">​</a></h3><ul><li><strong>目的驱动</strong>：只在必要时添加注释。注释的核心是解释“为什么这么做”，而不是“这是什么”。应重点阐述代码背后的设计思想、业务背景或特殊考量。</li><li><strong>语言</strong>：注释应使用中文。</li></ul><h2 id="_2-api-设计规范" tabindex="-1">2. API 设计规范 <a class="header-anchor" href="#_2-api-设计规范" aria-label="Permalink to &quot;2. API 设计规范&quot;">​</a></h2><h3 id="_2-1-基础接口命名" tabindex="-1">2.1. 基础接口命名 <a class="header-anchor" href="#_2-1-基础接口命名" aria-label="Permalink to &quot;2.1. 基础接口命名&quot;">​</a></h3><p>为了保持项目结构的一致性和可预测性，所有资源（Resource）的 CRUD 操作应遵循以下标准方法命名。控制器（Controller）和服务（Service）层的方法名必须保持一致。</p><ul><li><code>findOne</code>：获取单个资源。</li><li><code>findList</code>：获取资源列表（分页）。</li><li><code>findAll</code>：获取所有资源列表（不分页）。</li><li><code>create</code>：创建单个资源。</li><li><code>createMany</code>：批量创建资源（可选）。</li><li><code>update</code>：更新单个资源。</li><li><code>delete</code>：永久删除单个资源。</li><li><code>deleteMany</code>：批量永久删除资源（可选）。</li><li><code>remove</code>：逻辑删除（软删除）单个资源。</li><li><code>removeMany</code>：批量逻辑删除资源（可选）。</li><li><code>restore</code>：恢复被逻辑删除的资源。</li><li><code>restoreMany</code>：批量恢复被逻辑删除的资源（可选）。</li></ul><h3 id="_2-2-http-方法" tabindex="-1">2.2. HTTP 方法 <a class="header-anchor" href="#_2-2-http-方法" aria-label="Permalink to &quot;2.2. HTTP 方法&quot;">​</a></h3><ul><li>为简化客户端和网关的实现，API 仅使用 <code>GET</code> 和 <code>POST</code> 两种 HTTP 方法。不使用其他方法（如 <code>PUT</code>, <code>DELETE</code>, <code>PATCH</code> 等）。 <ul><li><code>GET</code>：用于请求数据，参数通过 URL 查询字符串传递。</li><li><code>POST</code>：用于提交数据（创建/更新）或执行需要复杂参数的查询操作。</li></ul></li></ul><h3 id="_2-3-查询接口" tabindex="-1">2.3. 查询接口 <a class="header-anchor" href="#_2-3-查询接口" aria-label="Permalink to &quot;2.3. 查询接口&quot;">​</a></h3><h4 id="_2-3-1-复杂查询" tabindex="-1">2.3.1. 复杂查询 <a class="header-anchor" href="#_2-3-1-复杂查询" aria-label="Permalink to &quot;2.3.1. 复杂查询&quot;">​</a></h4><ul><li><code>findList</code> 和 <code>findAll</code> 接口应使用 <code>POST</code> 方法，允许客户端通过请求体（Request Body）以 JSON 格式传递复杂的过滤和排序条件。</li></ul><h4 id="_2-3-2-查询模式-query-mode" tabindex="-1">2.3.2. 查询模式 (Query Mode) <a class="header-anchor" href="#_2-3-2-查询模式-query-mode" aria-label="Permalink to &quot;2.3.2. 查询模式 (Query Mode)&quot;">​</a></h4><ul><li><code>findList</code> 和 <code>findAll</code> 接口必须支持一个名为 <code>mode</code> 的 URL 查询参数，用于控制是否包含逻辑删除的数据。</li><li><code>mode</code> 参数的可选值如下： <ul><li><code>default</code>：默认模式，仅返回未被软删除的数据。</li><li><code>withDeleted</code>：返回所有数据，包括已被软删除的数据。</li><li><code>onlyDeleted</code>：仅返回已被软删除的数据。</li></ul></li><li>查询列表时，默认按照 <code>created_time</code> 字段降序排序。</li></ul><h4 id="findlist-等分页接口的参数规范" tabindex="-1">findList 等分页接口的参数规范 <a class="header-anchor" href="#findlist-等分页接口的参数规范" aria-label="Permalink to &quot;findList 等分页接口的参数规范&quot;">​</a></h4><ul><li>分页参数通过 <code>URL</code> 查询参数传递： <ul><li><code>currentPage</code>，表示当前页码，默认值为 <code>1</code>。</li><li><code>pageSize</code>，表示每页记录数，默认值为 <code>10</code></li></ul></li><li>对于 <code>findList</code> 等有筛选条件的接口，筛选参数应通过请求体（Request Body）以 JSON 格式传递。</li></ul><p>由于默认已经按照创建时间倒序，因此一般情况下不需要传递排序参数。如果确实需要自定义排序，可以在 URL Query 中传递 <code>sortBy</code> 和 <code>sortOrder</code> 参数。</p><ul><li><code>sortBy</code>：指定排序字段的名称。</li><li><code>sortOrder</code>：指定排序顺序，可选值为 <code>0</code>（降序）和 <code>1</code>（升序），默认值为 <code>0</code>。</li></ul><p>带分页的接口，<code>data</code> 字段的结构如下，并做成 VO 用于统一设置：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;total&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 总记录数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;currentPage&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 当前页码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;pageSize&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 每页记录数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;records&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 当前页的记录数组</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>pageSize</code> 最大限制为 <code>150</code>，如果超过则报错。</p><h3 id="_2-4-api-响应结构" tabindex="-1">2.4. API 响应结构 <a class="header-anchor" href="#_2-4-api-响应结构" aria-label="Permalink to &quot;2.4. API 响应结构&quot;">​</a></h3><p>所有 API 响应都应遵循统一的 JSON 结构，以便客户端进行标准化处理。</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;businessCode&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 业务状态码，0 表示成功，非 0 表示具体错误类型，注意，这不是 HTTP 状态码！</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // HTTP 状态码，前端诸如 Axios 等库会自动处理该字段，后端无需在响应体中返回。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;isSuccess&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误时为 false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;操作成功！&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误时返回错误信息</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;a348f08c-8c9e-4bac-95bd-146750cfb064&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;示例数据&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回的数据对象，错误时候为 null</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;timestamp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2025-11-05T07:44:01.608Z&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ISO 8601 格式的时间戳</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;errors&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 可选，详细的错误信息列表，复杂业务错误时使用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>响应还应包含 <code>X-Request-ID</code> 头，用于请求追踪。</li></ul><h5 id="businesscode-状态码" tabindex="-1">businessCode 状态码 <a class="header-anchor" href="#businesscode-状态码" aria-label="Permalink to &quot;businessCode 状态码&quot;">​</a></h5><ul><li><code>0</code>：操作成功</li><li><code>1xxx</code>：系统级错误（如数据库连接失败、超时等）</li><li><code>2xxx</code>：认证/鉴权失败（包括 <code>withDeleted</code> 和 <code>onlyDeleted</code> 等权限不足导致的问题）</li><li><code>3xxx</code>：参数错误（如缺少必填参数、参数格式错误等）</li><li><code>4xxx</code>：非数据库的业务逻辑错误（包括 <code>withDeleted</code> 和 <code>onlyDeleted</code> 等权限不足的鉴权错误）</li><li><code>5xxx</code>：数据库相关错误</li><li><code>9xxx</code>：未知错误</li></ul><h3 id="_2-5-权限控制" tabindex="-1">2.5. 权限控制 <a class="header-anchor" href="#_2-5-权限控制" aria-label="Permalink to &quot;2.5. 权限控制&quot;">​</a></h3><p>后端项目应当使用基于角色的访问控制（RBAC）模型来管理 API 权限。每个 API 方法都应对应一个唯一的权限点。</p><ul><li><strong>权限点命名</strong>：权限点的标识符应与 API 的方法名严格对应，以实现精细化的访问控制。例如，<code>create</code> 方法对应的权限点为 <code>create</code>。</li><li><strong>查询模式权限</strong>： <ul><li>查看已删除数据的能力应被视为特殊权限。</li><li>当 <code>mode=withDeleted</code> 时，用户需具备 <code>withDeleted</code> 权限。</li><li>当 <code>mode=onlyDeleted</code> 时，用户需具备 <code>onlyDeleted</code> 权限。</li><li><code>findAll</code> 由于查出的数据量过于巨大，为了防止被滥用导致性能问题，所以必须要有独立的权限点 <code>findAll</code>。</li></ul></li><li><strong>软删除权限</strong>： <ul><li><code>remove</code>/<code>removeMany</code>（软删除）和 <code>restore</code>/<code>restoreMany</code>（恢复）操作也必须有独立的权限点。</li></ul></li></ul><h3 id="_2-6-api-版本管理" tabindex="-1">2.6 API 版本管理 <a class="header-anchor" href="#_2-6-api-版本管理" aria-label="Permalink to &quot;2.6 API 版本管理&quot;">​</a></h3><p>所有 API 都应包含版本标识。推荐使用 URL 路径进行版本控制，例如 <code>/v1/system/user/findAll</code>。当发生不兼容的 API 变更时，应发布新的版本（如 v2），并为旧版本提供一段过渡期。</p><h3 id="_2-7-文件" tabindex="-1">2.7 文件 <a class="header-anchor" href="#_2-7-文件" aria-label="Permalink to &quot;2.7 文件&quot;">​</a></h3><ul><li>应当支持流式下载和断点续传。</li></ul><h2 id="_3-数据模型与数据库规范" tabindex="-1">3. 数据模型与数据库规范 <a class="header-anchor" href="#_3-数据模型与数据库规范" aria-label="Permalink to &quot;3. 数据模型与数据库规范&quot;">​</a></h2><h3 id="_3-1-对象定义" tabindex="-1">3.1. 对象定义 <a class="header-anchor" href="#_3-1-对象定义" aria-label="Permalink to &quot;3.1. 对象定义&quot;">​</a></h3><p>根据不同的使用场景，后端项目中常见的数据对象包括以下几种：</p><ul><li><p><strong>数据模型 (Data Model)</strong>：与数据库表结构一一对应的代码对象，用于数据操作。命名可以叫 <code>User</code>，一些技术栈中也称为实体（Entity）。项目里既然有公共字段，那么就需要有类似 <code>BaseModel</code> 或 <code>BaseEntity</code> 的基础数据模型供其他数据模型继承。</p></li><li><p><strong>DTO (Data Transfer Object)</strong>：用于在不同层之间（如客户端与服务端）传输数据的对象，通常作为 API 的输入参数。对于 DTO，可以这样命名：<code>CreateUserDTO</code>。</p></li><li><p><strong>VO (View Object)</strong>：用于服务端返回给客户端的视图层对象。如果其结构与 DTO 相同，可复用，命名方式为 <code>FindListVO</code>。</p></li></ul><p>对于 Go 等语言，它是没有类的概念的，因此上述对象均使用结构体（Struct）来定义。 Go 等语言也因此没有继承的概念，对于 Go，可以使用结构体嵌套的方式来实现类似继承的效果。如果所使用的语言也不支持嵌套，可以使用组合的方式来实现类似效果。</p><h3 id="_3-2-表与字段" tabindex="-1">3.2. 表与字段 <a class="header-anchor" href="#_3-2-表与字段" aria-label="Permalink to &quot;3.2. 表与字段&quot;">​</a></h3><h4 id="_3-2-1-命名规范" tabindex="-1">3.2.1. 命名规范 <a class="header-anchor" href="#_3-2-1-命名规范" aria-label="Permalink to &quot;3.2.1. 命名规范&quot;">​</a></h4><ul><li><strong>表名</strong>：必须采用下划线命名法（<code>snake_case</code>），例如 <code>user_profiles</code>。</li><li><strong>列名</strong>：同样采用下划线命名法。</li></ul><h4 id="_3-2-2-数据类型" tabindex="-1">3.2.2. 数据类型 <a class="header-anchor" href="#_3-2-2-数据类型" aria-label="Permalink to &quot;3.2.2. 数据类型&quot;">​</a></h4><ul><li><strong>时间类型</strong>：统一使用带时区的 <code>timestamptz</code> 类型，时区必须为 <code>UTC</code>。</li><li><strong>精确数值</strong>：对于金额、汇率等需要高精度计算的字段，必须使用 <code>decimal</code> 或 <code>numeric</code> 类型。</li><li><strong>大文本</strong>：对于不确定长度的大段文本，应使用 <code>text</code> 类型。</li></ul><h4 id="_3-2-3-公共字段" tabindex="-1">3.2.3. 公共字段 <a class="header-anchor" href="#_3-2-3-公共字段" aria-label="Permalink to &quot;3.2.3. 公共字段&quot;">​</a></h4><p>所有数据表都应包含一组标准化的公共字段，以记录元数据。</p><ul><li><p><code>id</code> （主键）: 唯一标识符，数据库类型为 <code>UUID</code>。</p></li><li><p><code>created_time</code> （创建时间）：记录创建时的时间戳，数据库类型为 <code>timestamptz</code>。</p></li><li><p><code>updated_time</code> （更新时间）：记录最后一次更新时的时间戳，数据库类型为 <code>timestamptz</code>。</p></li><li><p><code>deleted_time</code> （软删除时间）：可选，记录逻辑删除的时间戳，<code>NULL</code> 表示未删除，数据库类型为 <code>timestamptz</code>。</p></li><li><p><code>created_by</code> （创建者）：可选，创建该记录的用户的 UUID，数据库类型为 <code>UUID</code>。允许为 NULL，用以表示该记录由系统自动创建或更新，而非某个特定用户。</p></li><li><p><code>updated_by</code> （更新者）：可选，最后一次更新该记录的用户或系统标识，数据库类型为 <code>UUID</code>。允许为 NULL，用以表示该记录由系统自动创建或更新，而非某个特定用户。</p></li><li><p><code>deleted_by</code> （删除者）：可选，逻辑删除该记录的用户的 UUID，数据库类型为 <code>UUID</code>。允许为 NULL，用以表示该记录由系统自动删除，而非某个特定用户。</p></li><li><p><code>status</code> （状态）：记录当前的状态（通用版本），<code>0</code> 代表无效，<code>1</code> 代表有效，数据库类型为 <code>smallint</code>。</p></li><li><p><code>remark</code>（备注）：用于存储额外信息的文本字段，数据库类型为 <code>text</code>。</p></li></ul><p><strong>注意</strong>：<code>status</code> 字段表示资源本身的业务状态，而非逻辑删除状态。逻辑删除应通过 <code>deleted_time</code> 字段来实现，两者职责分离。 目前新项目使用了 <code>PostgreSQL 18.x</code>，它原生支持 <code>uuidv7</code>，因此在 <code>18.x</code> 及以上版本中，推荐使用 <code>uuidv7</code> 作为 UUID 的生成策略。 在定义表结构时，可以将 <code>id</code> 字段的默认值设置为 <code>uuid_generate_v7()</code> 函数，例如</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> my_table</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    id UUID </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">PRIMARY KEY</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> DEFAULT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uuid_generate_v7(),</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    -- ... other columns</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>如果项目中使用了 ORM，请参考相应 ORM 的文档，了解如何配置 UUIDv7 作为主键生成策略。</p><h3 id="_3-3-关系-relation" tabindex="-1">3.3. 关系 (Relation) <a class="header-anchor" href="#_3-3-关系-relation" aria-label="Permalink to &quot;3.3. 关系 (Relation)&quot;">​</a></h3><ul><li><strong>关系类型</strong>：应根据业务需求选择合适的关系类型（如一对一、一对多、多对多），避免滥用多对多关系。</li><li><strong>不用外键</strong>：外键并不适合所有场景。在高并发写入场景下，外键可能导致性能瓶颈。对于关系，可以通过应用层逻辑来维护数据完整性，而非依赖数据库外键约束。 <ul><li>由于不采用数据库外键约束，数据一致性的保障责任完全转移到应用层。开发人员必须通过以下方式确保数据完整性： <ul><li>在执行关联写入操作时，必须使用事务。</li><li>在删除或更新关联数据时，必须先检查是否存在相关联的数据，防止出现孤立记录。</li><li>定期运行数据完整性检查脚本，发现并修复潜在的数据不一致问题。</li></ul></li></ul></li></ul><h3 id="_3-4-查询与操作" tabindex="-1">3.4. 查询与操作 <a class="header-anchor" href="#_3-4-查询与操作" aria-label="Permalink to &quot;3.4. 查询与操作&quot;">​</a></h3><ul><li><strong>参数化查询</strong>：所有数据库查询都必须使用参数化（Prepared Statements），以从根本上防止 SQL 注入。</li><li><strong>避免 <code>SELECT *</code></strong>：查询时必须明确指定需要的字段，减少不必要的数据传输和数据库开销。</li><li><strong>避免 N+1 查询</strong>：严禁在循环中执行数据库查询。应通过 <code>IN</code> 查询或 <code>JOIN</code> 将多次查询合并为一次。</li><li><strong>复杂查询</strong>：对于涉及多表连接（JOIN）、聚合、子查询等复杂场景，推荐使用原生 SQL 或数据库访问库提供的查询构建工具，以保证代码的可读性和性能。</li></ul><h3 id="_3-5-事务-transaction" tabindex="-1">3.5. 事务 (Transaction) <a class="header-anchor" href="#_3-5-事务-transaction" aria-label="Permalink to &quot;3.5. 事务 (Transaction)&quot;">​</a></h3><ul><li><strong>原子性</strong>：任何涉及多个写操作的业务逻辑都必须封装在事务中，以保证操作的原子性。</li><li><strong>缩短事务时长</strong>：避免在事务中执行耗时的操作，如外部 API 调用、文件 I/O 等，以减少锁竞争和数据库压力。</li></ul><h3 id="_3-6-数据库结构变更-migration" tabindex="-1">3.6. 数据库结构变更 (Migration) <a class="header-anchor" href="#_3-6-数据库结构变更-migration" aria-label="Permalink to &quot;3.6. 数据库结构变更 (Migration)&quot;">​</a></h3><ul><li><strong>禁用自动同步</strong>：在生产环境中，必须禁用任何自动同步数据库结构的功能。</li><li><strong>迁移脚本</strong>：所有数据库结构变更（DDL）都必须通过迁移脚本进行管理。每个迁移脚本应是原子的、可回滚的。</li></ul><h3 id="_3-7-异常处理" tabindex="-1">3.7. 异常处理 <a class="header-anchor" href="#_3-7-异常处理" aria-label="Permalink to &quot;3.7. 异常处理&quot;">​</a></h3><ul><li><strong>封装数据库错误</strong>：严禁将原始的数据库错误信息直接暴露给客户端。</li><li><strong>统一处理</strong>：应使用全局异常处理机制来捕获数据库异常，并将其转换为标准化的错误响应。</li><li><strong>记录日志</strong>：在捕获异常时，应记录详细的错误日志，以便于问题排查。</li></ul><h3 id="_3-8-索引" tabindex="-1">3.8. 索引 <a class="header-anchor" href="#_3-8-索引" aria-label="Permalink to &quot;3.8. 索引&quot;">​</a></h3><ul><li>应当根据查询需求合理创建索引，以提升查询性能。</li></ul><h2 id="_4-配置管理" tabindex="-1">4. 配置管理 <a class="header-anchor" href="#_4-配置管理" aria-label="Permalink to &quot;4. 配置管理&quot;">​</a></h2><ul><li><strong>环境变量优先</strong>：所有配置项（如数据库凭证、API 密钥、服务端口等）应优先通过环境变量读取。</li><li><strong>配置文件</strong>：可以提供一个默认的配置文件，但不应将包含敏感信息的配置文件提交到版本控制系统中。</li><li><strong>分离不同环境</strong>：应为开发、测试、生产等不同环境提供独立的配置。</li></ul><h2 id="_5-日志规范" tabindex="-1">5. 日志规范 <a class="header-anchor" href="#_5-日志规范" aria-label="Permalink to &quot;5. 日志规范&quot;">​</a></h2><ul><li><strong>结构化日志</strong>：日志应采用 JSON 格式，方便机器解析和平台收集。</li><li><strong>日志级别</strong>：合理使用不同的日志级别（如 <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>）。生产环境通常只记录 <code>INFO</code> 及以上级别。</li></ul><h2 id="_6-鉴权和安全规范" tabindex="-1">6. 鉴权和安全规范 <a class="header-anchor" href="#_6-鉴权和安全规范" aria-label="Permalink to &quot;6. 鉴权和安全规范&quot;">​</a></h2><ul><li>基础鉴权使用 <code>JWT</code>，如果项目有必要则引入 <code>OAuth2.0</code>。</li><li>密码必须加盐，使用 <code>argon2id</code>。</li><li>虽然客户端会进行输入校验，但后端必须对重要输入进行再校验。</li><li>所有敏感数据（如密码、API 密钥等）在存储和传输过程中必须进行加密处理。</li><li>严禁在日志或 API 响应中直接输出密码、密钥、身份证号等敏感信息。</li></ul><h2 id="_7-项目结构" tabindex="-1">7. 项目结构 <a class="header-anchor" href="#_7-项目结构" aria-label="Permalink to &quot;7. 项目结构&quot;">​</a></h2><p>应根据所使用的技术栈，采用社区推荐的项目结构。确保代码模块化、职责单一，便于维护和扩展。</p><h2 id="_8-文档" tabindex="-1">8. 文档 <a class="header-anchor" href="#_8-文档" aria-label="Permalink to &quot;8. 文档&quot;">​</a></h2><ul><li>必须使用 OpenAPI(Swagger) 生成 API 文档。</li><li>每个接口都应包含清晰的描述、参数说明、响应示例。</li></ul><h2 id="_9-容器化" tabindex="-1">9. 容器化 <a class="header-anchor" href="#_9-容器化" aria-label="Permalink to &quot;9. 容器化&quot;">​</a></h2><p>如果项目使用容器化部署，应遵循以下规范：</p><ul><li>使用多阶段构建优化镜像大小。</li></ul>`,83)])])}const u=e(o,[["render",t]]);export{k as __pageData,u as default};
