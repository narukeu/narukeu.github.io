<!DOCTYPE html>
<html lang="zh-Hans" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>原生工具浪潮下 Babel 的定位与未来演进 | Luke Na's Docs</title>
    <meta name="description" content="Web 文章、资料、代码片段等内容">
    <meta name="generator" content="VitePress v2.0.0-alpha.12">
    <link rel="preload stylesheet" href="/assets/style.DruoqU4u.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.hAw52G0L.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/theme.aOfyCkKj.js">
    <link rel="modulepreload" href="/assets/chunks/framework.lo-SgHyK.js">
    <link rel="modulepreload" href="/assets/articles_babel-in-future.md.CH5cqZUc.lean.js">
    <link rel="icon" href="/favicon.png">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-ecd09619><!--[--><!--]--><!--[--><span tabindex="-1" data-v-f7052d3b></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-f7052d3b>Skip to content</a><!--]--><!----><header class="VPNav" data-v-ecd09619 data-v-9862a508><div class="VPNavBar" data-v-9862a508 data-v-a036aacc><div class="wrapper" data-v-a036aacc><div class="container" data-v-a036aacc><div class="title" data-v-a036aacc><div class="VPNavBarTitle has-sidebar" data-v-a036aacc data-v-e9396610><a class="title" href="/" data-v-e9396610><!--[--><!--]--><!----><span data-v-e9396610>Luke Na&#39;s Docs</span><!--[--><!--]--></a></div></div><div class="content" data-v-a036aacc><div class="content-body" data-v-a036aacc><!--[--><!--]--><div class="VPNavBarSearch search" data-v-a036aacc><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-a036aacc data-v-a84596d2><span id="main-nav-aria-label" class="visually-hidden" data-v-a84596d2> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-a84596d2 data-v-ead08302><!--[--><span data-v-ead08302>主页</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-a036aacc data-v-cfd1510d><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-cfd1510d data-v-bd3c1a51 data-v-8f367072><span class="check" data-v-8f367072><span class="icon" data-v-8f367072><!--[--><span class="vpi-sun sun" data-v-bd3c1a51></span><span class="vpi-moon moon" data-v-bd3c1a51></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-a036aacc data-v-9f8ec710 data-v-93f3f618><!--[--><a class="VPSocialLink no-icon" href="https://github.com/narukeu" aria-label="github" target="_blank" rel="me noopener" data-v-93f3f618 data-v-0596cbc3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-a036aacc data-v-d0a6dac3 data-v-b0156ee2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-b0156ee2><span class="vpi-more-horizontal icon" data-v-b0156ee2></span></button><div class="menu" data-v-b0156ee2><div class="VPMenu" data-v-b0156ee2 data-v-72472372><!----><!--[--><!--[--><!----><div class="group" data-v-d0a6dac3><div class="item appearance" data-v-d0a6dac3><p class="label" data-v-d0a6dac3>Appearance</p><div class="appearance-action" data-v-d0a6dac3><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-d0a6dac3 data-v-bd3c1a51 data-v-8f367072><span class="check" data-v-8f367072><span class="icon" data-v-8f367072><!--[--><span class="vpi-sun sun" data-v-bd3c1a51></span><span class="vpi-moon moon" data-v-bd3c1a51></span><!--]--></span></span></button></div></div></div><div class="group" data-v-d0a6dac3><div class="item social-links" data-v-d0a6dac3><div class="VPSocialLinks social-links-list" data-v-d0a6dac3 data-v-93f3f618><!--[--><a class="VPSocialLink no-icon" href="https://github.com/narukeu" aria-label="github" target="_blank" rel="me noopener" data-v-93f3f618 data-v-0596cbc3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-a036aacc data-v-f9fd6b90><span class="container" data-v-f9fd6b90><span class="top" data-v-f9fd6b90></span><span class="middle" data-v-f9fd6b90></span><span class="bottom" data-v-f9fd6b90></span></span></button></div></div></div></div><div class="divider" data-v-a036aacc><div class="divider-line" data-v-a036aacc></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-ecd09619 data-v-a417cc13><div class="container" data-v-a417cc13><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a417cc13><span class="vpi-align-left menu-icon" data-v-a417cc13></span><span class="menu-text" data-v-a417cc13>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a417cc13 data-v-0a86b8e5><button data-v-0a86b8e5>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-ecd09619 data-v-06100c94><div class="curtain" data-v-06100c94></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-06100c94><span class="visually-hidden" id="sidebar-aria-label" data-v-06100c94> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-45c21dcd><section class="VPSidebarItem level-0" data-v-45c21dcd data-v-f326af2d><!----><div class="items" data-v-f326af2d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-f326af2d data-v-f326af2d><div class="item" data-v-f326af2d><div class="indicator" data-v-f326af2d></div><a class="VPLink link link" href="/articles.html" data-v-f326af2d><!--[--><p class="text" data-v-f326af2d>简介</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-45c21dcd><section class="VPSidebarItem level-0" data-v-45c21dcd data-v-f326af2d><div class="item" role="button" tabindex="0" data-v-f326af2d><div class="indicator" data-v-f326af2d></div><h2 class="text" data-v-f326af2d>TypeScript</h2><!----></div><div class="items" data-v-f326af2d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-f326af2d data-v-f326af2d><div class="item" data-v-f326af2d><div class="indicator" data-v-f326af2d></div><a class="VPLink link link" href="/articles/rewrite-relative-import-extensions.html" data-v-f326af2d><!--[--><p class="text" data-v-f326af2d>聊下 `rewriteRelativeImportExtensions` 这个 TS 配置项</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-45c21dcd><section class="VPSidebarItem level-0" data-v-45c21dcd data-v-f326af2d><div class="item" role="button" tabindex="0" data-v-f326af2d><div class="indicator" data-v-f326af2d></div><h2 class="text" data-v-f326af2d>Linux</h2><!----></div><div class="items" data-v-f326af2d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-f326af2d data-v-f326af2d><div class="item" data-v-f326af2d><div class="indicator" data-v-f326af2d></div><a class="VPLink link link" href="/articles/linux-keep-usb-alive.html" data-v-f326af2d><!--[--><p class="text" data-v-f326af2d>使用 Systemd 防止移动硬盘休眠</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-45c21dcd><section class="VPSidebarItem level-0 has-active" data-v-45c21dcd data-v-f326af2d><div class="item" role="button" tabindex="0" data-v-f326af2d><div class="indicator" data-v-f326af2d></div><h2 class="text" data-v-f326af2d>技术杂谈</h2><!----></div><div class="items" data-v-f326af2d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-f326af2d data-v-f326af2d><div class="item" data-v-f326af2d><div class="indicator" data-v-f326af2d></div><a class="VPLink link link" href="/articles/oh-frontend.html" data-v-f326af2d><!--[--><p class="text" data-v-f326af2d>聊下前端 —— 关于我的职业经历和前端是否会被“取代”的碎碎念</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f326af2d data-v-f326af2d><div class="item" data-v-f326af2d><div class="indicator" data-v-f326af2d></div><a class="VPLink link link" href="/articles/babel-in-future.html" data-v-f326af2d><!--[--><p class="text" data-v-f326af2d>原生工具浪潮下 Babel 的定位与未来演进</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f326af2d data-v-f326af2d><div class="item" data-v-f326af2d><div class="indicator" data-v-f326af2d></div><a class="VPLink link link" href="/articles/sharp-comment-bun.html" data-v-f326af2d><!--[--><p class="text" data-v-f326af2d>从 Anthropic 收购 Bun 谈起，聊聊 Bun 的败局</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f326af2d data-v-f326af2d><div class="item" data-v-f326af2d><div class="indicator" data-v-f326af2d></div><a class="VPLink link link" href="/articles/i-choose-avoid.html" data-v-f326af2d><!--[--><p class="text" data-v-f326af2d>90% 代码用 AI 写？我拒了 Offer，也拒了所有华而不实的“网红技术”</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-45c21dcd><section class="VPSidebarItem level-0" data-v-45c21dcd data-v-f326af2d><div class="item" role="button" tabindex="0" data-v-f326af2d><div class="indicator" data-v-f326af2d></div><h2 class="text" data-v-f326af2d>规范</h2><!----></div><div class="items" data-v-f326af2d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-f326af2d data-v-f326af2d><div class="item" data-v-f326af2d><div class="indicator" data-v-f326af2d></div><a class="VPLink link link" href="/articles/frontend-dev-conventions.html" data-v-f326af2d><!--[--><p class="text" data-v-f326af2d>Node.js 项目开发规范</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f326af2d data-v-f326af2d><div class="item" data-v-f326af2d><div class="indicator" data-v-f326af2d></div><a class="VPLink link link" href="/articles/frontend-naming-conventions.html" data-v-f326af2d><!--[--><p class="text" data-v-f326af2d>Node.js 项目风格和命名规范</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f326af2d data-v-f326af2d><div class="item" data-v-f326af2d><div class="indicator" data-v-f326af2d></div><a class="VPLink link link" href="/articles/backend-rules.html" data-v-f326af2d><!--[--><p class="text" data-v-f326af2d>后端项目开发规范</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f326af2d data-v-f326af2d><div class="item" data-v-f326af2d><div class="indicator" data-v-f326af2d></div><a class="VPLink link link" href="/articles/nestjs-dev-conventions.html" data-v-f326af2d><!--[--><p class="text" data-v-f326af2d>NestJS 开发规范</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f326af2d data-v-f326af2d><div class="item" data-v-f326af2d><div class="indicator" data-v-f326af2d></div><a class="VPLink link link" href="/articles/go-conventions.html" data-v-f326af2d><!--[--><p class="text" data-v-f326af2d>Go 语言项目开发规范</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f326af2d data-v-f326af2d><div class="item" data-v-f326af2d><div class="indicator" data-v-f326af2d></div><a class="VPLink link link" href="/articles/uber-go.html" data-v-f326af2d><!--[--><p class="text" data-v-f326af2d>Uber Go 风格指南（译）</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-ecd09619 data-v-82bea445><div class="VPDoc has-sidebar has-aside" data-v-82bea445 data-v-d9c38dcc><!--[--><!--]--><div class="container" data-v-d9c38dcc><div class="aside" data-v-d9c38dcc><div class="aside-curtain" data-v-d9c38dcc></div><div class="aside-container" data-v-d9c38dcc><div class="aside-content" data-v-d9c38dcc><div class="VPDocAside" data-v-d9c38dcc data-v-4b4c377a><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-4b4c377a data-v-2ea41e1b><div class="content" data-v-2ea41e1b><div class="outline-marker" data-v-2ea41e1b></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-2ea41e1b>On this page</div><ul class="VPDocOutlineItem root" data-v-2ea41e1b data-v-c302e66c><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-4b4c377a></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-d9c38dcc><div class="content-container" data-v-d9c38dcc><!--[--><!--]--><main class="main" data-v-d9c38dcc><div style="position:relative;" class="vp-doc _articles_babel-in-future" data-v-d9c38dcc><div><h1 id="原生工具浪潮下-babel-的定位与未来演进" tabindex="-1">原生工具浪潮下 Babel 的定位与未来演进 <a class="header-anchor" href="#原生工具浪潮下-babel-的定位与未来演进" aria-label="Permalink to “原生工具浪潮下 Babel 的定位与未来演进”">​</a></h1><blockquote><p>“Rust 正在吃掉 JavaScript”</p></blockquote><p>—— 这句话来自 Lee Robinson 的文章[^1]，作者是前任的 Vercel VP。</p><p>他坚信 Rust 是 JavaScript 工具的未来，他洋洋洒洒地列举了不少理由，并且，从现在的 Next.js 来看，他们默认使用了自己用 Rust 写的构建工具 Turbopack。</p><p>微软也干了[^2]，今年年初，他们宣布了 TypeScript 7.x 将使用 Go 开发，从目前 GitHub 上来看，进展还不错，实现了不少东西。</p><p>字节还搞了 Rspack，从我看的一些讨论来看，相对于 Webpack，提升蛮大的。</p><p>当然其他基于 JavaScript 的解析、转译、打包工具也是这样，Babel 算一个典型，我们来聊聊 Babel 在原生工具浪潮下的定位与未来演进。</p><h2 id="_1-原生工具的兴起" tabindex="-1">1. 原生工具的兴起 <a class="header-anchor" href="#_1-原生工具的兴起" aria-label="Permalink to “1. 原生工具的兴起”">​</a></h2><p>Babel 有一个很典型的场景，就是开发 React 应用时的 JSX 转译，在过去几乎是一个事实标准，在 <code>create-react-app</code>（React 曾经的官方脚手架，现已废弃）等用到了 WebPack 技术栈的脚手架里，<code>babel-loader</code> 就是默认配置，大家下意识地就用 Babel 来转译 JSX。我记得在我刚学前端的时候，Babel 几乎就是转译的代名词。</p><p>现在情况还是有变化的，</p><p>Next.js 在国外算是网红级别的框架了，它现在已经启用了 Turbopack 作为默认打包工具，而且是生产环境可用，它默认就使用了 SWC 来转译 React JSX。</p><p>Rspack 是由字节主导的 Rspack 以 Rust 重写了一个高度兼容 Webpack 的打包器。它内置了 <code>swc-loader</code>，默认就以 SWC 来处理 JS/TS/JSX 的解析与转译，从而绕开 Babel。</p><p>SWC 官网上说，</p><blockquote><p>“SWC is 20x[^3] faster than Babel on a single thread and 70x faster on four cores.”</p></blockquote><p>至于有没有 20 倍、70 倍，我具体没算过，但是给我的直观使用感受，确实快不少，尤其是在大型项目里，Babel 那种“卡顿感”会更明显一些，而 SWC 则流畅很多。</p><p>用 npm trends 的数据[^12]来看，<code>@swc/core</code> 在 2023.1.8 - 2023.1.15 周下载量是 1,745,152，一年后（2024.1.17 - 2024.1.14） 5,342,485，到了 2025.11.16 - 2025.11.23，这个数字已经达到了 15,453,205，可以说是爆发式增长。</p><p>从 GitHub 的 Star 数来看，SWC 约 33k，Babel 约 43k，差距也在缩小[12]。</p><p>国内用 VoidZero 的东西还是比较多的（毕竟 Vue 技术栈的统治地位），VoidZero 开源了 OXC 这个项目（它是用 Rust 写的，上层建筑是 Rolldown 以及 Rolldown Vite），它的重要职责包括转译和解析 ，从官方数据来看，也是很明显的性能提升。</p><h2 id="_2-为什么-babel-被原生工具轻而易举地吃掉份额" tabindex="-1">2. 为什么 Babel 被原生工具轻而易举地吃掉份额 <a class="header-anchor" href="#_2-为什么-babel-被原生工具轻而易举地吃掉份额" aria-label="Permalink to “2. 为什么 Babel 被原生工具轻而易举地吃掉份额”">​</a></h2><h3 id="_2-1-性能维度的降维打击-底层算力-这关过不去" tabindex="-1">2.1 性能维度的降维打击：“底层算力”这关过不去 <a class="header-anchor" href="#_2-1-性能维度的降维打击-底层算力-这关过不去" aria-label="Permalink to “2.1 性能维度的降维打击：“底层算力”这关过不去”">​</a></h3><p>这个在上一章已经提到过了，对于大型项目来说，构建时间的长短不仅影响直接的开发体验，也间接影响着程序员的工作效率。</p><p>Babel 是用 JavaScript 写的，运行在 Node.js 这类 JavaScript 运行时上。</p><p>它在处理 AST 时，需要经过：源码解析、JS 对象分配、大量临时节点创建、垃圾回收等多个环节， 对于大型项目，AST 规模巨大，JS 对象分配非常频繁，Node.js 的 GC 停顿就会形成明显的“忽快忽慢”。哪怕工程师在 Babel 内部做了大量缓存与增量编译优化，也很难从根本上抹平这种抖动。</p><p>Node.js 的 JavaScript 执行模型以单线程事件循环为核心，虽然可以通过 <code>worker_threads</code> 或多进程并行处理多个文件，但跨线程 / 进程通信本身就有序列化、反序列化和调度开销，调度粒度也相对粗，这让它在“需要高频访问 AST、频繁分配对象”的编译类任务上比较吃力。</p><p>当然，这也不只是 Node.js 一家如此，哪怕是号称最快 JS 运行时的 Bun，当主要编译逻辑仍然用 JavaScript 实现时，也很难从根本上绕过 GC、对象分配模型等带来的开销。</p><p>而 SWC（Rust）和 esbuild（Go）编译为原生二进制文件。它们直接运行在操作系统上，使用更高效的内存管理策略，相比运行在 JS 引擎中的工具，基本没有解释执行带来的额外开销。这种底层语言的优势，就像是开着跑车去和骑自行车的人赛跑，基础能力的差距无法通过简单的优化来弥补。</p><p>Rust 和 Go 在语言层面对多线程 / 并发的支持更直接，很多编译器 / 构建工具也会默认吃满多核，这种并发模型上的优势，在 CPU 密集的转译任务里会非常直观地体现在构建时间上。</p><p>对于大厂和大型项目来说，缩短构建时间，也能节省大量的计算资源和成本。原生工具取代 Babel 处理转译任务，不是因为 Babel 做错了什么，而是因为在计算密集型的转译任务中，JavaScript 已经触碰到了物理极限。</p><h3 id="_2-2-先前的-babel-版本给用户的痛点" tabindex="-1">2.2 先前的 Babel 版本给用户的痛点 <a class="header-anchor" href="#_2-2-先前的-babel-版本给用户的痛点" aria-label="Permalink to “2.2 先前的 Babel 版本给用户的痛点”">​</a></h3><p>下面介绍一些 Babel 的部分痛点。</p><h4 id="_2-2-1-默认编译目标过于保守-性能和包体被-历史包袱-拖累" tabindex="-1">2.2.1 默认编译目标过于保守，性能和包体被“历史包袱”拖累 <a class="header-anchor" href="#_2-2-1-默认编译目标过于保守-性能和包体被-历史包袱-拖累" aria-label="Permalink to “2.2.1 默认编译目标过于保守，性能和包体被“历史包袱”拖累”">​</a></h4><p>Babel 默认的编译目标是 <code>&gt;=0%</code>，这意味着它会生成大量为了兼容旧浏览器（如 IE11）而产生的冗余代码。这不仅增加了构建时间，也导致了生成代码的体积膨胀。</p><p>在 Babel 7 中，如果用户没有显式配置 <code>targets</code>，官方文档说明 Babel 会“假定你在支持最旧的浏览器”，<code>@babel/preset-env</code> 会把 ES2015–ES2020 全部降级到 ES5，Babel 7 官方文档[^7]里也说，</p><blockquote><p>“When no targets are specified: Babel will assume you are targeting the oldest browsers possible. For example, @babel/preset-env will transform all ES2015-ES2020 code to be ES5 compatible.”</p></blockquote><p>更重要的是，这种“极度保守”的默认行为在很多项目里是隐式发生的：很多团队并没有配置 targets，却在不知情的情况下默默为 IE11 买单。这种“隐式陷阱”放大了 Babel 带来的负面直觉。</p><p>从体验的角度看，这相当于你花了同样的编译时间，结果输出了一堆根本用不上的 polyfill 和降级代码 —— 构建变慢、包变大，但团队日常面对的现代浏览器根本享受不到什么“实质收益”，自然会让人觉得这时间“白耗了”。</p><h4 id="_2-2-2-配置复杂、不够直观" tabindex="-1">2.2.2 配置复杂、不够直观 <a class="header-anchor" href="#_2-2-2-配置复杂、不够直观" aria-label="Permalink to “2.2.2 配置复杂、不够直观”">​</a></h4><p>如果一个库的配置过于复杂，用户在使用时就会感到困惑和不便。社区在批评 Webpack 的时候也提到了类似的问题。</p><p>以装饰器（Decorators）为例，Babel 的配置和使用就相对复杂，尤其是在不同版本的装饰器提案之间切换时，用户需要了解各种细节和兼容性问题。Babel 7 提供了各种版本[8]，甚至彼此之间不完全兼容，用户怎么知道自己需要哪个版本呢？这无疑就增加了学习成本和使用难度。</p><p>社区里关于 <code>decoratorsBeforeExport</code> / <code>legacy</code> / <code>version</code> 组合踩坑的问答非常多，例如 Stack Overflow 上就有多个问题围绕“报错：decorators 插件需要 <code>decoratorsBeforeExport</code>、如何配置 <code>legacy decorators</code> 与 <code>class‑properties</code> 的顺序等展开，答案往往需要给出精确的 Babel 配置才能消除错误。 这些讨论间接证明了 Babel 7 在 decorators 提案多版本同时存在时，给最终用户带来了显著的配置负担。</p><h4 id="_2-2-3-babel-的-typescript-的-ast-形式和-typescript-eslint-不一致" tabindex="-1">2.2.3 Babel 的 TypeScript 的 AST 形式和 typescript-eslint 不一致 <a class="header-anchor" href="#_2-2-3-babel-的-typescript-的-ast-形式和-typescript-eslint-不一致" aria-label="Permalink to “2.2.3 Babel 的 TypeScript 的 AST 形式和 typescript-eslint 不一致”">​</a></h4><p>在 Eslint 的 GitHub 讨论（#18830）中，@bradzacher 明确提到：</p><p>“我想指出的一点是使用 Babel 作为 TypeScript 解析器的问题。尽管 Babel（以及由此衍生的 <code>@babel/eslint-parser</code>）确实支持 TypeScript 语法，但它们输出的 AST 是其自身的一套表示形式，与 typescript-eslint 的 AST 规范并不一致。”[^9]</p><p>开发 ESLint 插件或多工具集成时，作者往往需要针对 Babel AST 和 <code>typescript‑eslint</code> AST 分别写一套逻辑，或者在项目里引入额外的 AST 适配层，这在大型项目中是一笔不小的维护成本，也使得 Babel 在“作为通用 AST 解析器”这一角色上略显孤立。</p><h4 id="_2-2-4-极度碎片化带来的-微包地狱-极度原子化" tabindex="-1">2.2.4 极度碎片化带来的“微包地狱”，极度原子化 <a class="header-anchor" href="#_2-2-4-极度碎片化带来的-微包地狱-极度原子化" aria-label="Permalink to “2.2.4 极度碎片化带来的“微包地狱”，极度原子化”">​</a></h4><p>Babel 8 在这一点上改进了很多，但是在 Babel 7 时代，Babel 的生态系统已经高度碎片化，用户需要安装和配置多个插件和预设才能满足不同的转译需求。这种“微包地狱”不仅增加了配置的复杂性，也使得依赖管理变得困难。</p><p>或者说，Babel 7 原来的做法过于激进，我在 4.4 节提到 Babel 未来可以专注于特定领域，这确实需要原子化，但是旧版本 Babel 未免太激进了点。</p><p>虽然 preset-env 缓解了这个问题，但一旦遇到 preset-env 覆盖不到的边缘特性，或者需要调试依赖冲突时，这种“原子化”的包结构会导致 node_modules 极其臃肿。</p><h2 id="_3-babel-8" tabindex="-1">3. Babel 8 <a class="header-anchor" href="#_3-babel-8" aria-label="Permalink to “3. Babel 8”">​</a></h2><p>针对多年来社区对 Babel 做的批评，他们也在自我革新。既然算力比不过，那就把第 2 章提到的那些“非性能”痛点（配置繁琐、标准不统一、历史包袱重）解决掉，做一个更轻量、更标准的现代化工具。</p><p>截止到写这一段的时候（2025.11.23），Babel 8 最新版本为 <code>8.0.0-beta.3</code>。</p><p>Babel 8 发布计划的时候，我还是个学生，如今，终于有了 Beta。</p><h3 id="_3-1-全面拥抱-esm" tabindex="-1">3.1 全面拥抱 ESM <a class="header-anchor" href="#_3-1-全面拥抱-esm" aria-label="Permalink to “3.1 全面拥抱 ESM”">​</a></h3><p>这是 Babel 8 最激进的变化之一[^5]。当然我并不感到意外，ES6 规范都发布 10 年了，Node.js 也支持 ESM 很久了，Babel 作为一个现代 JavaScript 工具，迟早要做出这个改变。</p><p>但是，Babel 在我们心目中，可能还有那种，它是老旧的、或者说，是兼容老旧玩意的刻板印象，它能全面拥抱 ESM 确实是一个积极的信号，表明它在努力跟上现代 JavaScript 生态的发展步伐。</p><h3 id="_3-2-放弃对旧版本-node-js-的支持" tabindex="-1">3.2 放弃对旧版本 Node.js 的支持 <a class="header-anchor" href="#_3-2-放弃对旧版本-node-js-的支持" aria-label="Permalink to “3.2 放弃对旧版本 Node.js 的支持”">​</a></h3><p>从最新的文档来看，它要求 Node.js 版本 <code>^20.19.0 || &gt;=22.12.0</code>，彻底放弃了对旧版本 Node.js 的支持[^5]。新版本的 Node.js 中不仅有性能改进，还有很多不错的新 API。这不仅对于 Babel 开发者来说是不错的，对于更多的使用者而言，也必是一个好事。</p><p>既然原生工具已经基本接管了“兼容老环境 + 极致性能”的那块地盘，Babel 再坚持支持一堆远古 Node 其实意义不大，不如彻底站到“现代 Node + 现代生态”的那一边，把精力花在它现在还能发挥优势的场景上。</p><h3 id="_3-3-配置简化、重构" tabindex="-1">3.3 配置简化、重构 <a class="header-anchor" href="#_3-3-配置简化、重构" aria-label="Permalink to “3.3 配置简化、重构”">​</a></h3><p>@babel/core 终于将 targets 从 <code>&gt;=0%</code> 变成了 <code>defaults</code>，这意味着默认情况下，Babel 不会再生成一大堆为了兼容 IE 而产生的冗余代码。</p><p>装饰器问题，Babel 8 只保留了 2023-11 和 legacy 两个版本[^8]，由于浏览器即将实现的也是最新一版 <code>decorators</code> 提案，Babel 官方在迁移文档中明确建议，即便短期仍可使用 legacy，也应当优先升级到 2023-11[^5]，这样一方面与 TypeScript 5.x 行为一致，另一方面也避免了未来浏览器原生 <code>decorators</code> 与 Babel 输出不一致的问题。</p><p>Babel 8 把这些配置收紧，本质上是在抹掉“历史问题导致的负面体验”，让它在那些仍需要 Babel 参与的场景里，不至于被骂“慢又臃肿”。也就是说，它并不能帮 Babel 打赢和 SWC 的速度战，但至少能让人不再因为“配置坑”下意识排斥 Babel。</p><h3 id="_3-4-生态对齐与输出产物的现代化" tabindex="-1">3.4 生态对齐与输出产物的现代化 <a class="header-anchor" href="#_3-4-生态对齐与输出产物的现代化" aria-label="Permalink to “3.4 生态对齐与输出产物的现代化”">​</a></h3><p>除了显而易见的配置简化，Babel 8 在底层逻辑上也回应了社区长久以来的抱怨，尤其是在生态对齐和产物质量上。</p><h4 id="_3-4-1-首先是解决-typescript-ast-的分裂问题。" tabindex="-1">3.4.1 首先是解决 TypeScript AST 的分裂问题。 <a class="header-anchor" href="#_3-4-1-首先是解决-typescript-ast-的分裂问题。" aria-label="Permalink to “3.4.1 首先是解决 TypeScript AST 的分裂问题。”">​</a></h4><p>我们在 2.2.3 节提到过，Babel 之前的 TypeScript AST 与 <code>typescript-eslint</code> 存在差异，这让工具开发者极其痛苦。Babel 8 终于着手解决了这个问题，在迁移文档中明确提到，Babel 8 对 TypeScript 节点的解析逻辑进行了调整，以尽可能减少与 <code>@typescript-eslint</code> 项目的 AST 形状差异[^6]。</p><p>官方说，“这将使编写 ESLint 规则变得更加容易，当不依赖类型信息时，这些规则可以同时在 <code>@typescript-eslint/parser</code> 和 <code>@babel/eslint-parser</code> 下工作。”[^6]</p><p>这意味着，未来开发基于 AST 的工具（如自定义 ESLint 规则或 Codemod）时，开发者不再需要在两套标准之间反复横跳，这对于维护一个统一的 JavaScript/TypeScript 工具链生态至关重要。</p><h4 id="_3-4-2-其次是默认开启-bugfixes-模式-13-告别-暴力降级-。" tabindex="-1">3.4.2 其次是默认开启 <code>bugfixes</code> 模式[^13]，告别“暴力降级”。 <a class="header-anchor" href="#_3-4-2-其次是默认开启-bugfixes-模式-13-告别-暴力降级-。" aria-label="Permalink to “3.4.2 其次是默认开启 bugfixes 模式[^13]，告别“暴力降级”。”">​</a></h4><p>Babel 8 开启 <code>bugfixes</code> 模式，以前 Babel 转译像“一刀切”。比如你的目标浏览器支持大部分 ES6 类（Class），但只在一个很小的边缘情况有 Bug。旧模式下，Babel 会把所有 Class 代码都转译成 ES5 的函数（代码量大，性能差），默认开启 <code>bugfixes</code> 之后，Babel 变得更聪明。它会利用浏览器原生支持的语法，只针对那个特定的 Bug 注入一点点补丁代码，而不是把整个语法都重写。这样使得让编译后的代码更接近现代语法，体积更小，运行更快。</p><h3 id="_3-5-babel-8-能逆转颓势吗" tabindex="-1">3.5 Babel 8 能逆转颓势吗？ <a class="header-anchor" href="#_3-5-babel-8-能逆转颓势吗" aria-label="Permalink to “3.5 Babel 8 能逆转颓势吗？”">​</a></h3><p>Babel 8 的改进主要集中在清理技术债、规范化配置、提升开发者体验和对齐现代标准。虽然放弃旧 Node 版本和代码清理会带来微小的性能提升，但它本质上仍然运行在 JS 引擎之上，对于原生工具带来的降维打击是束手无策的，除非 Babel 自己也引入 Rust/Go 的代码。</p><p>“Babel 自己也引入 Rust/Go 的代码”，我也没有找到任何的直接证据来证明 Babel 有这个打算，或许 Babel 9 会有，但谁知道呢？</p><p>如果你把“逆转颓势”理解成，Babel 8 能够重新夺回原生工具已经抢走的市场份额，那我认为几乎不可能。</p><p>Babel 8 可以让原本因为“隐式陷阱”和“历史坑”而讨厌 Babel 的开发者，可以重新以一个更合理的成本使用它，以及在未来，Babel 8 扮演着自己在新时代的角色，我们下面会讲。</p><h2 id="_4-babel-8-的未来-以及它和原生工具的共处" tabindex="-1">4. Babel 8 的未来，以及它和原生工具的共处 <a class="header-anchor" href="#_4-babel-8-的未来-以及它和原生工具的共处" aria-label="Permalink to “4. Babel 8 的未来，以及它和原生工具的共处”">​</a></h2><p>上一章我们说了，Babel 8 逆转不了颓势，但它也不会“死”。在存量的 Babel 生态中可以继续发挥作用，用 npm trends 来看，其实它的下载量也没有明显下降。</p><h3 id="_4-1-babel-特性决定了它仍然是新特性的试验场" tabindex="-1">4.1 Babel 特性决定了它仍然是新特性的试验场 <a class="header-anchor" href="#_4-1-babel-特性决定了它仍然是新特性的试验场" aria-label="Permalink to “4.1 Babel 特性决定了它仍然是新特性的试验场”">​</a></h3><p>SWC 和 Esbuild 在策略上更偏向支持已经稳定、主流使用的特性，对仍在剧烈变化的实验性提案会相对谨慎。</p><p>Esbuild 的 FAQ 中[^10]也提到了，</p><blockquote><p>“If you have very custom requirements then you should be using other tools.”</p></blockquote><p>Next.js 最新的文档[^11]中，也有这么一句话：</p><blockquote><p>“If you have an existing Babel configuration or are using unsupported features, your application will opt-out of the Next.js Compiler and continue using Babel.”</p></blockquote><p>如果 SWC 能通过插件支持所有实验性特性，Next.js 就没必要设计这个“回退到 Babel”的机制。这至少说明，在处理一些非标准 / 实验性特性和高度定制的场景时，Next.js 仍然需要以 Babel 作为兜底方案。</p><p>当然，这没有对错之分，作为一个原生工具，SWC 和 Esbuild 当然是为了成熟的特性而设计的。我也是 SWC 用户，我当然希望 SWC 主要支持稳定的特性。而 Babel 毕竟是 JavaScript 写的，它可以更灵活地跟进 ECMAScript 提案的进展，快速实现和试验新特性。既然要快速验证原型，我认为没有必要用原生工具来做这件事，毕竟开发效率才是关键。</p><p>从事实上来看，Babel 也确实有大量的实验性特性插件（babel-plugin-proposal-xxx），都是在正式成为标准之前就被 Babel 支持了。</p><h3 id="_4-2-除试验场外-babel-还可以专注特定情形下的用例" tabindex="-1">4.2 除试验场外，Babel 还可以专注特定情形下的用例 <a class="header-anchor" href="#_4-2-除试验场外-babel-还可以专注特定情形下的用例" aria-label="Permalink to “4.2 除试验场外，Babel 还可以专注特定情形下的用例”">​</a></h3><p>大家可能听说过 <code>jscodeshift</code>，是 Facebook 开源的一个工具。专门用于在大规模代码库中运行自动化的重构脚本。Ant Design 就使用了它，可以去看一下 <code>@ant-design/codemod-v5</code> 的依赖。</p><p>没错，它也用了 Babel，不过，它不是拿来转译代码的，而是用来做代码分析和重构的。</p><p>在构建场景下，我们关注输入的源码，输出的代码机器能正常跑就行，但是在 Codemod 场景下，我们会要求几乎无损地修改。</p><p><code>jscodeshift</code> 依赖一个叫 recast 的库来重新打印代码以保留格式。而 recast 以及整个 JS 静态分析生态，默认通用的“语言”就是 Babel 定义的 AST 规范（<code>@babel/types</code>）。</p><p>Babel 在此角色确实做了退化，它作为解析存在。</p><p>但这并不是原生工具也能轻松代替的。</p><p>原生工具当然也能做 Parser，它也有自己的 AST。但它们的设计初衷是“编译”，它的 AST 是为了 Rust 编译器优化而设计的，结构上与 Babel 的 AST 存在差异。</p><p>而且用原生工具实在是杀鸡用牛刀，迁移脚本和编译不同，我的脚本跑一次节省几秒钟的时间，其实没那么重要。而且作为前端应用的开发者，他真的不一定会 Rust、Go 等语言，如果为了用原生工具，就得学一门新语言，这显然是不划算的。即使在 LLM 普及的今天，学一门编程语言，也真的不是特别容易。</p><p>只要我们还需要自动化重构工具，Babel 就依然是这一领域的首选。让原生工具为了这个边缘场景去重写一套保留格式的解析器，既不划算，也背离了它们“高性能编译器”的初衷。</p><p>如果你说完成这些工作靠 LLM，我觉得还是把这种情形的重构任务交给一个相对来说更能确定结果的工具更好。</p><h4 id="_4-2-1-从更宏观的角度看-babel-其实已经在-事实标准-ast-这条路差不多站稳了。" tabindex="-1">4.2.1 从更宏观的角度看，Babel 其实已经在“事实标准 AST”这条路差不多站稳了。 <a class="header-anchor" href="#_4-2-1-从更宏观的角度看-babel-其实已经在-事实标准-ast-这条路差不多站稳了。" aria-label="Permalink to “4.2.1 从更宏观的角度看，Babel 其实已经在“事实标准 AST”这条路差不多站稳了。”">​</a></h4><p><code>@babel/parser</code> 的官方文档中介绍说，Babel 解析器根据 Babel AST 格式生成 AST，且是在 ESTree 规范上进行的微调，它还提供了 estree 插件，能抹掉这些不符合 estree 的偏差。</p><p>从实际情况上来看，<code>@babel/parser</code> 生成的 AST 已经成为了 JavaScript 静态分析领域的事实标准，我们熟悉的 Prettier[^14] ，就是基于 Babel AST 进行处理的。Eslint 也可也使用 <code>@babel/eslint-parser</code> 进行解析。</p><p>Dennis O&#39;Keeffe 有一篇小教程，叫《Creating Your Own Language》[^15]，教你怎么自己做一个玩具语言的，关于 AST 部分，他也提到：</p><blockquote><p>“Babel is kind of the de facto standard for the AST” —— Babel 是 AST 的事实标准。</p></blockquote><p>Babel 作为转译器，它在原生工具面前确实没有竞争力，可是 Babel 到今天可不止是一个转译器，它也成为了前端开发基础设施（转译器器）中的基础设施（转译器的基础）。</p><p>虽然有 Biome 等新的、用 Rust 编写的 Linter + Formatter 工具在冲击着 Eslint 和 Prettier，但从目前来看，后两者的统治地位仍然稳固，而它们对 Babel AST 的依赖也不会轻易改变。后两者依赖 Babel Parser 是比较出名的，还有更多的开源项目。</p><h3 id="_4-3-原生工具为了实用性-也支持-js-插件-但是" tabindex="-1">4.3 原生工具为了实用性，也支持 JS 插件，但是： <a class="header-anchor" href="#_4-3-原生工具为了实用性-也支持-js-插件-但是" aria-label="Permalink to “4.3 原生工具为了实用性，也支持 JS 插件，但是：”">​</a></h3><p>4.1 节我们已经其实已经提到了，Babel 的开发门槛相对较低，而且毕竟也是动态的语言，这使得它在快速迭代和试验新特性方面具有优势。</p><p>我觉得到这里，会有读者问，其实有原生工具已经支持用 JS 写插件了，你的论点并不可靠。</p><p>这里补充说一下。</p><p>现在很多原生工具也提供了 JS API，以 esbuild 为例，当构建过程触发特定钩子（Hooks，如 <code>onResolve</code>, <code>onLoad</code>）时，Go 进程会将控制权交还给 Node.js 里的 JS 插件，插件处理完后再将结果传回 Go。</p><p>这是有代价的，这就是序列化和反序列化的开销。</p><p>频繁地在原生进程和 JS 进程间切换会带来性能损失，尤其是当插件逻辑复杂、调用频繁时，这种损失会更加明显。如果插件逻辑过于频繁（例如处理每一个 AST 节点），这种开销可能会抵消原生工具带来的性能优势。</p><p>况且，JS 插件运行在“与内核不同的语言和运行时”中，调试体验、错误栈信息等都比“纯 JS 工具链”更复杂，对需要频繁修改和迭代的 DSL 编译逻辑而言，这种复杂度未必值得。</p><p>原生工具支持 JS 插件是一种实用主义的妥协，它承认了 JavaScript 在构建配置领域的统治地位。</p><h3 id="_4-4-存量的-babel-生态-就算迁移到原生工具也需要时间和精力" tabindex="-1">4.4 存量的 Babel 生态，就算迁移到原生工具也需要时间和精力 <a class="header-anchor" href="#_4-4-存量的-babel-生态-就算迁移到原生工具也需要时间和精力" aria-label="Permalink to “4.4 存量的 Babel 生态，就算迁移到原生工具也需要时间和精力”">​</a></h3><p>这是倒数第二重要的，所以我放到后面讲。</p><p>Solidjs 不知道大家有没有听说过，这是一个很新的框架，它用法上类似 React，但是它不使用虚拟 DOM，而是通过编译时优化来实现高性能，可以理解成，“JSX 风格的 Svelte”。</p><p>截止到写这一段的时候（2025.11.23），SolidJS 官方提供的插件仍然是基于 Babel 而不是 SWC 的。</p><p><code>babel-preset-solid</code> 依赖 <code>babel-plugin-jsx-dom-expressions</code> 进行转译，这是 SolidJS 转译的核心，篇幅有限，我们可以简单分析一下。</p><p>当然，<code>babel-plugin-jsx-dom-expressions</code> 是一个很极端的例子，Babel 生态环境中的相当多的插件并不会复杂到这个程度，但这正是“现有 Babel 生态过于复杂、原生工具难以完全替代”的一个典型样本。</p><p>React JSX 转译的主要工作，是把各种 JSX 变成 <code>React.createElement(...)</code>，本质上是一种较为单纯的语法糖映射。Solid 则完全不同，它几乎把“运行时该干的事”尽量搬到了编译期。</p><p>它会对每个 JSX 表达式做“静态 / 动态”判定、尽可能在编译期折叠出 HTML 字符串模板、只把真正需要响应式更新的点，记录到一个 dynamics 列表，交给运行时 effect 去更新。</p><p>插件有一个体量不小的 <code>isDynamic</code> 函数，专门回答一个问题：“这个表达式在运行时会不会变？”，它要考虑的远远不止“是不是字面量”这么简单，它围绕 Solid 自己的信号 / effect 模型精心写的一整套“静态分析 + 编译期调度”逻辑。</p><p>在 CSR 和 SSR 下的行为也不一样，具体不再赘述。诸位有兴趣可以拉下源码用 AI 分析一下。</p><p>综上所述，它实质上是一个利用 JavaScript 的动态能力，构建在 Babel AST 之上的“领域特定语言（DSL）编译器”和“浏览器环境模拟器”。</p><p>你要问 SWC 能不能实现一样的逻辑？当然没问题，我没有看出它有哪些东西是 SWC 做不到的，但是，重写这个插件，我觉得不是几周甚至小几个月就能做完的事情。</p><p>@vitejs/plugin-vue-jsx 也是如此，它仍然是依赖 Babel 的（<code>@vue/babel-plugin-jsx</code>），虽然不像 SolidJS 那么复杂，但它也有自己的一套 Vue 特有的 JSX，也要处理 Vue 独有语法糖和运行时优化。我目前也没有看到 VoidZero 旗下的项目在官方的 GitHub 仓库里有用 OXC 改写 Vue JSX 插件。虽然 Vue JSX 用 OXC 可能也只是时间问题，但短期内，Babel 仍然是第一选择。</p><h3 id="_4-5-babel-会是一个备用选项" tabindex="-1">4.5 Babel 会是一个备用选项 <a class="header-anchor" href="#_4-5-babel-会是一个备用选项" aria-label="Permalink to “4.5 Babel 会是一个备用选项”">​</a></h3><p>这节我放到最后说，也不会写太多，因为相对上面内容来说，它应该是最不重要的，或许，极端情况下，这种的“备用选项”甚至不会被用到。</p><p>Next.js 并没有完全抛弃 Babel，在最新的 Next.js 16 文档中，仍然保留了 Babel 的相关配置选项，用户仍然可以在 SWC 无法完成的情况下，使用 Babel 来处理转译任务。</p><p>Vite 也是，我知道 VoidZero 已经开发出了 OXC、Rolldown，<code>@vitejs/plugin-react</code> 默认仍然是基于 Babel 的。</p><h2 id="_5-结语" tabindex="-1">5. 结语 <a class="header-anchor" href="#_5-结语" aria-label="Permalink to “5. 结语”">​</a></h2><p>Babel 迎来了它自己的转折点。它的原型是人类因为自己的傲慢而被迫分散的象征。但 JavaScript 世界里的 Babel，它却在相当长的一段时间里，抹平了不同环境、不同技术、不同年代的差异，让开发者能够专注于编写代码，而不是担心兼容性问题。如今原生工具的普及，Babel 不会停工，而是在新的时代里，找到自己的定位。</p><h2 id="_6-参考资料" tabindex="-1">6. 参考资料 <a class="header-anchor" href="#_6-参考资料" aria-label="Permalink to “6. 参考资料”">​</a></h2><p>[^1]: Rust Is Eating JavaScript, Lee Robinson, <a href="https://leerob.com/rust" target="_blank" rel="noreferrer">https://leerob.com/rust</a></p><p>[^2]: A 10x Faster TypeScript, Anders Hejlsberg, <a href="https://devblogs.microsoft.com/typescript/typescript-native-port/" target="_blank" rel="noreferrer">https://devblogs.microsoft.com/typescript/typescript-native-port/</a></p><p>[^3]: SWC 官网, <a href="https://swc.rs" target="_blank" rel="noreferrer">https://swc.rs</a></p><p>[^4]: Announcing Babel 8 Beta, Babel Team, <a href="https://next.babeljs.io/blog/2025/05/30/babel-8-beta" target="_blank" rel="noreferrer">https://next.babeljs.io/blog/2025/05/30/babel-8-beta</a></p><p>[^5]: Upgrade to Babel 8, Babel Team, <a href="https://next.babeljs.io/docs/v8-migration/" target="_blank" rel="noreferrer">https://next.babeljs.io/docs/v8-migration/</a></p><p>[^6]: Upgrade to Babel 8 (API), Babel Team, <a href="https://next.babeljs.io/docs/v8-migration-api" target="_blank" rel="noreferrer">https://next.babeljs.io/docs/v8-migration-api</a></p><p>[^7]: Babel 配置选项, Babel Team, <a href="https://babeljs.io/docs/options#targets" target="_blank" rel="noreferrer">https://babeljs.io/docs/options#targets</a></p><p>[^8]: Babel Plugin Proposal Decorators, Babel Team, <a href="https://babeljs.io/docs/babel-plugin-proposal-decorators#version" target="_blank" rel="noreferrer">https://babeljs.io/docs/babel-plugin-proposal-decorators#version</a></p><p>[^9]: Rethinking TypeScript support in ESLint, Nicholas C. Zakas and Brad Zacher, <a href="https://github.com/eslint/eslint/discussions/18830" target="_blank" rel="noreferrer">https://github.com/eslint/eslint/discussions/18830</a></p><p>[^10]: Esbuild FAQ, Evan Wallace, <a href="https://esbuild.github.io/faq" target="_blank" rel="noreferrer">https://esbuild.github.io/faq</a></p><p>[^11]: Next.js Compiler, Vercel, <a href="https://nextjs.org/docs/architecture/nextjs-compiler" target="_blank" rel="noreferrer">https://nextjs.org/docs/architecture/nextjs-compiler</a></p><p>[^12]: @swc/core 和 @babel/core 的趋势数据, npm trends, <a href="https://npmtrends.com/@babel/core-vs-@swc/core" target="_blank" rel="noreferrer">https://npmtrends.com/@babel/core-vs-@swc/core</a></p><p>[^13]: Babel 8 Bugfixes Mode, Babel Team, <a href="https://babeljs.io/docs/babel-preset-env#bugfixes" target="_blank" rel="noreferrer">https://babeljs.io/docs/babel-preset-env#bugfixes</a></p><p>[^14]: Prettier 的 package.json, GitHub, <a href="https://github.com/prettier/prettier/raw/refs/heads/main/package.json" target="_blank" rel="noreferrer">https://github.com/prettier/prettier/raw/refs/heads/main/package.json</a></p><p>[^15]: Creating Your Own Language, Dennis O&#39;Keeffe, <a href="https://docs.dennisokeeffe.com/programming-languages/creating-your-own-language" target="_blank" rel="noreferrer">https://docs.dennisokeeffe.com/programming-languages/creating-your-own-language</a></p></div></div></main><footer class="VPDocFooter" data-v-d9c38dcc data-v-3ee9435d><!--[--><!--]--><div class="edit-info" data-v-3ee9435d><!----><div class="last-updated" data-v-3ee9435d><p class="VPLastUpdated" data-v-3ee9435d data-v-70e428c2>最后更新于: <time datetime="2025-11-26T06:43:50.000Z" data-v-70e428c2></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-3ee9435d><span class="visually-hidden" id="doc-footer-aria-label" data-v-3ee9435d>Pager</span><div class="pager" data-v-3ee9435d><a class="VPLink link pager-link prev" href="/articles/oh-frontend.html" data-v-3ee9435d><!--[--><span class="desc" data-v-3ee9435d>Previous page</span><span class="title" data-v-3ee9435d>聊下前端 —— 关于我的职业经历和前端是否会被“取代”的碎碎念</span><!--]--></a></div><div class="pager" data-v-3ee9435d><a class="VPLink link pager-link next" href="/articles/sharp-comment-bun.html" data-v-3ee9435d><!--[--><span class="desc" data-v-3ee9435d>Next page</span><span class="title" data-v-3ee9435d>从 Anthropic 收购 Bun 谈起，聊聊 Bun 的败局</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"articles_babel-in-future.md\":\"CH5cqZUc\",\"articles_backend-rules.md\":\"C1mul3aG\",\"articles_frontend-dev-conventions.md\":\"ORcaGNsA\",\"articles_frontend-naming-conventions.md\":\"BshYNUdS\",\"articles_go-conventions.md\":\"tSRy46Fo\",\"articles_i-choose-avoid.md\":\"CfTfbmhO\",\"articles_index.md\":\"Cst0NQZ5\",\"articles_linux-keep-usb-alive.md\":\"b2nVDqUO\",\"articles_nestjs-dev-conventions.md\":\"BRIi-fSK\",\"articles_oh-frontend.md\":\"Duqa2JPK\",\"articles_rewrite-relative-import-extensions.md\":\"D0_n7eW7\",\"articles_sharp-comment-bun.md\":\"BYVJl9X6\",\"articles_uber-go.md\":\"Dix67vrt\",\"codes_add-jitter.md\":\"R0r3xtof\",\"codes_array-get-value-by-select-data.md\":\"eXA59KMY\",\"codes_array-sum.md\":\"jXrpe947\",\"codes_biomejs-config.md\":\"DZpCdJ--\",\"codes_build-query-string.md\":\"CkanAejy\",\"codes_convert-px-rem.md\":\"wFYLNGTU\",\"codes_eslint-flat-config.md\":\"dpkv4kYE\",\"codes_filter-array-with-index-by-id.md\":\"CNv9UN6x\",\"codes_frontend-gitignore.md\":\"BlKx7VrM\",\"codes_index.md\":\"SUPKpK-6\",\"codes_is-empty.md\":\"Drp-6LD3\",\"codes_simple-uid.md\":\"DBK9N-wl\",\"design-doc_index.md\":\"D3l0KUBF\",\"design-doc_packer.md\":\"B5kElKWn\",\"design-doc_ripple.md\":\"DbiwPYwA\",\"index.md\":\"BMsYpxVp\",\"spring_index.md\":\"CotZEMhK\",\"spring_microservice-auth.md\":\"DotXUpaU\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-Hans\",\"dir\":\"ltr\",\"title\":\"Luke Na's Docs\",\"description\":\"Web 文章、资料、代码片段等内容\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"主页\",\"link\":\"/\"}],\"sidebar\":{\"/articles\":[{\"text\":\"简介\",\"link\":\"/articles\"},{\"text\":\"TypeScript\",\"items\":[{\"text\":\"聊下 `rewriteRelativeImportExtensions` 这个 TS 配置项\",\"link\":\"/articles/rewrite-relative-import-extensions\"}]},{\"text\":\"Linux\",\"items\":[{\"text\":\"使用 Systemd 防止移动硬盘休眠\",\"link\":\"/articles/linux-keep-usb-alive\"}]},{\"text\":\"技术杂谈\",\"items\":[{\"text\":\"聊下前端 —— 关于我的职业经历和前端是否会被“取代”的碎碎念\",\"link\":\"/articles/oh-frontend\"},{\"text\":\"原生工具浪潮下 Babel 的定位与未来演进\",\"link\":\"/articles/babel-in-future\"},{\"text\":\"从 Anthropic 收购 Bun 谈起，聊聊 Bun 的败局\",\"link\":\"/articles/sharp-comment-bun\"},{\"text\":\"90% 代码用 AI 写？我拒了 Offer，也拒了所有华而不实的“网红技术”\",\"link\":\"/articles/i-choose-avoid\"}]},{\"text\":\"规范\",\"items\":[{\"text\":\"Node.js 项目开发规范\",\"link\":\"/articles/frontend-dev-conventions\"},{\"text\":\"Node.js 项目风格和命名规范\",\"link\":\"/articles/frontend-naming-conventions\"},{\"text\":\"后端项目开发规范\",\"link\":\"/articles/backend-rules\"},{\"text\":\"NestJS 开发规范\",\"link\":\"/articles/nestjs-dev-conventions\"},{\"text\":\"Go 语言项目开发规范\",\"link\":\"/articles/go-conventions\"},{\"text\":\"Uber Go 风格指南（译）\",\"link\":\"/articles/uber-go\"}]}],\"/codes\":[{\"text\":\"简介\",\"items\":[{\"text\":\"代码片段\",\"link\":\"/codes\"}]},{\"text\":\"配置文件\",\"items\":[{\"text\":\"前端通用 .gitignore\",\"link\":\"/codes/frontend-gitignore\"},{\"text\":\"BiomeJS 配置\",\"link\":\"/codes/biomejs-config\"},{\"text\":\"Eslint 配置\",\"link\":\"/codes/eslint-flat-config\"}]},{\"text\":\"类型判断\",\"items\":[{\"text\":\"isEmpty 判空函数\",\"link\":\"/codes/is-empty\"}]},{\"text\":\"数组\",\"items\":[{\"text\":\"对象数组指定键求和\",\"link\":\"/codes/array-sum\"},{\"text\":\"根据选择数据获取标签\",\"link\":\"/codes/array-get-value-by-select-data\"},{\"text\":\"根据 id 列表从对象数组中过滤出项并返回匹配项和在其在原数组的索引\",\"link\":\"/codes/filter-array-with-index-by-id\"}]},{\"text\":\"对象\",\"items\":[{\"text\":\"将对象转换为 URL 查询字符串\",\"link\":\"/codes/build-query-string\"}]},{\"text\":\"随机\",\"items\":[{\"text\":\"简易版生成 UID 函数\",\"link\":\"/codes/simple-uid\"},{\"text\":\"为给定的延迟时间添加抖动\",\"link\":\"/codes/add-jitter\"}]},{\"text\":\"数据显示\",\"items\":[{\"text\":\"实现 px 和 rem 的互相转换\",\"link\":\"/codes/convert-px-rem\"}]}],\"/design-doc\":[{\"text\":\"简介\",\"items\":[{\"text\":\"设计文档\",\"link\":\"/design-doc\"}]},{\"text\":\"Go\",\"items\":[{\"text\":\"基础设施设计文档\",\"link\":\"/design-doc/ripple.md\"}]}],\"/spring\":[{\"text\":\"简介\",\"link\":\"/spring\"},{\"text\":\"微服务\",\"items\":[{\"text\":\"微服务项目中鉴权逻辑\",\"link\":\"/spring/microservice-auth\"}]}]},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"full\",\"timeStyle\":\"medium\"}},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/narukeu\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false,\"additionalConfig\":{}}");</script>
    
  </body>
</html>